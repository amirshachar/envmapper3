{"/root/www/codeflow/webgl/envmapper3/lib/require.coffee":{"modified":1421591773429,"content":"var sys,\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nsys = {\n  modules: {},\n  files: {},\n  defModule: function(name, closure) {\n    return this.modules[name] = {\n      closure: closure,\n      instance: null\n    };\n  },\n  defFile: function(name, value) {\n    return this.files[name] = value;\n  },\n  loadImage: function(name, callback) {\n    var img;\n    img = new Image();\n    img.onload = function() {\n      return callback(name, img);\n    };\n    img.onerror = function() {\n      return console.error('failed to load: ' + name);\n    };\n    img.src = 'src' + name;\n  },\n  main: function() {\n    return this.require('/module');\n\n    /*\n     *window.addEventListener 'load', =>\n    document.addEventListener 'DOMContentLoaded', =>\n        toLoad = 0\n        loaded = 0\n        for name, value of @files\n            ext = name.split('.').pop()\n            if value is undefined\n                toLoad += 1\n                switch ext\n                    when 'png', 'jpg', 'jpeg', 'gif'\n                        @loadImage name, (imageName, img) =>\n                            @files[imageName] = img\n                            loaded += 1\n                            if loaded is toLoad\n                                @require('/module').main()\n        if loaded is toLoad\n            @require('/module').main()\n     */\n  },\n  abspath: function(fromName, pathName) {\n    var base, baseName, path;\n    if (pathName === '.') {\n      pathName = '';\n    }\n    baseName = fromName.split('/');\n    baseName.pop();\n    baseName = baseName.join('/');\n    if (pathName[0] === '/') {\n      return pathName;\n    } else {\n      path = pathName.split('/');\n      if (baseName === '/') {\n        base = [''];\n      } else {\n        base = baseName.split('/');\n      }\n      while (base.length > 0 && path.length > 0 && path[0] === '..') {\n        base.pop();\n        path.shift();\n      }\n      if (base.length === 0 || path.length === 0 || base[0] !== '') {\n        throw new Error(\"Invalid path: \" + (base.join('/')) + \"/\" + (path.join('/')));\n      }\n      return \"\" + (base.join('/')) + \"/\" + (path.join('/'));\n    }\n  },\n  File: (function() {\n    function _Class(path) {\n      this.path = path;\n      this.content = sys.files[this.path];\n      if (this.content == null) {\n        throw Error('file does not exist: ' + this.path);\n      }\n    }\n\n    _Class.prototype.read = function() {\n      return this.content;\n    };\n\n    return _Class;\n\n  })(),\n  FileSystem: (function() {\n    function _Class(origin) {\n      this.origin = origin;\n    }\n\n    _Class.prototype.abspath = function(fromName, pathName) {\n      var folders, part, path, _i, _len, _ref;\n      if (pathName[0] === '/') {\n        return pathName;\n      } else {\n        folders = fromName.split('/');\n        folders.pop();\n        path = [];\n        _ref = pathName.split('/');\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          part = _ref[_i];\n          if (part === '..') {\n            if (folders.length > 0) {\n              folders.pop();\n            } else {\n              path.push(part);\n            }\n          } else {\n            path.push(part);\n          }\n        }\n        return folders.concat(path).join('/');\n      }\n    };\n\n    _Class.prototype.listdir = function(path, _arg) {\n      var directories, files, name, result, type, value, _i, _len, _ref, _ref1;\n      type = _arg.type;\n      path = sys.abspath(this.origin, path);\n      result = [];\n      _ref = sys.modules;\n      for (name in _ref) {\n        value = _ref[name];\n        if (name.indexOf(path) === 0) {\n          name = name.slice(path.length + 1).split('/')[0];\n          if (__indexOf.call(result, name) < 0) {\n            result.push(name);\n          }\n        }\n      }\n      _ref1 = sys.files;\n      for (name in _ref1) {\n        value = _ref1[name];\n        if (name.indexOf(path) === 0) {\n          name = name.slice(path.length + 1).split('/')[0];\n          if (__indexOf.call(result, name) < 0) {\n            result.push(name);\n          }\n        }\n      }\n      directories = [];\n      files = [];\n      for (_i = 0, _len = result.length; _i < _len; _i++) {\n        name = result[_i];\n        if (this.isdir(path + '/' + name)) {\n          directories.push(name);\n        } else {\n          files.push(name);\n        }\n      }\n      switch (type) {\n        case 'directory':\n          return directories;\n        case 'file':\n          return files;\n        default:\n          return result;\n      }\n    };\n\n    _Class.prototype.isdir = function(path) {\n      var file, module, name, value, _ref, _ref1;\n      path = sys.abspath(this.origin, path);\n      module = sys.modules[path];\n      if (module != null) {\n        return false;\n      }\n      file = sys.files[path];\n      if (file != null) {\n        return false;\n      }\n      _ref = sys.modules;\n      for (name in _ref) {\n        value = _ref[name];\n        if (name.indexOf(path) === 0) {\n          return true;\n        }\n      }\n      _ref1 = sys.files;\n      for (name in _ref1) {\n        value = _ref1[name];\n        if (name.indexOf(path) === 0) {\n          return true;\n        }\n      }\n      throw new Error('Path does not exist: ' + path);\n    };\n\n    _Class.prototype.open = function(path) {\n      return new sys.File(sys.abspath(this.origin, path));\n    };\n\n    return _Class;\n\n  })(),\n  require: function(moduleName) {\n    var exports, fs, module, require;\n    if (moduleName != null) {\n      module = this.modules[moduleName];\n      if (module === void 0) {\n        module = this.modules[moduleName + '/module'];\n        if (module != null) {\n          moduleName = moduleName + '/module';\n        } else {\n          throw new Error('Module not found: ' + moduleName);\n        }\n      }\n      if (module.instance === null) {\n        require = (function(_this) {\n          return function(requirePath) {\n            var path;\n            path = _this.abspath(moduleName, requirePath);\n            return _this.require(path);\n          };\n        })(this);\n        fs = new sys.FileSystem(moduleName);\n        exports = {};\n        exports = module.closure(exports, require, fs);\n        module.instance = exports;\n      }\n      return module.instance;\n    } else {\n      throw new Error('no module name provided');\n    }\n  }\n};"},"/root/www/codeflow/webgl/envmapper3/src/module.coffee":{"modified":1454927680224,"content":"var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nsys.defModule('/module', function(exports, require, fs) {\n  var Accumulators, Application, Camera, Chart, Environment, Events, Samples, WebGL, compression, display, fileSystem, getBuffer, sphere;\n  WebGL = require('webgl');\n  Environment = require('environment');\n  Accumulators = require('accumulator');\n  Events = require('events');\n  Camera = require('camera');\n  Samples = require('samples');\n  Chart = require('chart');\n  compression = require('compression');\n  sphere = require('sphere');\n  getBuffer = require('get-buffer');\n  fileSystem = require('/file-system');\n  Application = (function() {\n    function Application() {\n      this.update = __bind(this.update, this);\n      this.fw = new WebGL();\n      $(this.fw.canvas).appendTo('body');\n      this.hub = new Events();\n      this.camera = new Camera(this);\n      this.samples = new Samples(this);\n      this.environment = new Environment(this);\n      this.accumulators = new Accumulators(this);\n      this.chart = new Chart();\n      this.params = {};\n      $('<button>Open HDR</button>').css({\n        position: 'absolute',\n        top: 10,\n        left: 10\n      }).appendTo('body').click((function(_this) {\n        return function() {\n          return _this.environment.openHDR();\n        };\n      })(this));\n      $('<button>Save</button>').css({\n        position: 'absolute',\n        top: 30,\n        left: 10\n      }).appendTo('body').click((function(_this) {\n        return function() {\n          return _this.save();\n        };\n      })(this));\n      this.addSlider('diffuseReflectance', 50 + 0 * 20);\n      this.addSlider('specularReflectance', 50 + 1 * 20);\n      this.addSlider('specularMix', 50 + 2 * 20);\n      this.addSlider('emissivity', 50 + 3 * 20);\n      this.addSlider('roughness1', 50 + 5 * 20);\n      this.addSlider('fresnel1', 50 + 6 * 20);\n      this.addSlider('metallness1', 50 + 7 * 20);\n      this.addSlider('roughness2', 50 + 9 * 20);\n      this.addSlider('fresnel2', 50 + 10 * 20);\n      this.addSlider('metallness2', 50 + 11 * 20);\n      this.addSlider('exposure', 50 + 13 * 20, -1, 1);\n      getBuffer('model.bin', (function(_this) {\n        return function(data) {\n          return _this.display = _this.fw.state({\n            shader: [fs.open('octahedral.shader'), fs.open('display.shader')],\n            vertexbuffer: {\n              pointers: [\n                {\n                  name: 'position',\n                  size: 3\n                }, {\n                  name: 'texcoord',\n                  size: 2\n                }, {\n                  name: 'normal',\n                  size: 3\n                }\n              ],\n              vertices: data\n            },\n            depthTest: true\n          });\n        };\n      })(this));\n      this.baseColor = this.fw.texture2D({\n        filter: 'linear',\n        width: 1,\n        height: 1\n      }).loadImage('images/base-color.png', true);\n      this.ao = this.fw.texture2D({\n        filter: 'linear',\n        width: 1,\n        height: 1\n      }).loadImage('images/ao.png', true);\n      this.cavity = this.fw.texture2D({\n        filter: 'linear',\n        width: 1,\n        height: 1\n      }).loadImage('images/cavity.png', true);\n      this.shadow = this.fw.texture2D({\n        filter: 'linear',\n        width: 1,\n        height: 1\n      }).loadImage('images/shadow.png', true);\n      this.update();\n    }\n\n    Application.prototype.addSlider = function(name, top, min, max, value) {\n      var row;\n      if (min == null) {\n        min = 0;\n      }\n      if (max == null) {\n        max = 1;\n      }\n      if (value == null) {\n        value = 0;\n      }\n      row = $('<div></div>').appendTo('body').css({\n        position: 'absolute',\n        left: 20,\n        top: top\n      });\n      $('<label></label>').text(name).css({\n        color: 'black',\n        display: 'inline-block',\n        width: 100\n      }).appendTo(row);\n      return this.params[name] = $('<input type=\"range\" step=\"0.001\">').attr({\n        min: min,\n        max: max,\n        value: value\n      }).css({\n        width: 300\n      }).appendTo(row)[0];\n    };\n\n    Application.prototype.getParams = function() {\n      var input, name, result, _ref;\n      result = {};\n      _ref = this.params;\n      for (name in _ref) {\n        input = _ref[name];\n        result[name] = parseFloat(input.value);\n      }\n      return result;\n    };\n\n    Application.prototype.update = function() {\n      var name, params, value, _, _i;\n      if (this.display != null) {\n        this.fw.frameStart();\n        this.camera.update();\n        for (_ = _i = 0; _i < 1; _ = ++_i) {\n          this.samples.generate();\n          this.accumulators.update();\n        }\n        params = this.getParams();\n        params.exposure = Math.pow(2, params.exposure * 5);\n        for (name in params) {\n          value = params[name];\n          this.display.float(name, value);\n        }\n        this.display.uniformSetter(this.camera).sampler('textureRadiance', this.accumulators.specular).vec2('radianceSize', this.accumulators.specular.width(), this.accumulators.specular.height()).sampler('textureBaseColor', this.baseColor).sampler('textureAO', this.ao).sampler('textureCavity', this.cavity).sampler('textureShadow', this.shadow).vec2('offset', 0, 0).draw();\n\n        /*\n            \n        for x in [0..10]\n            @display\n                .vec2('offset', (x-5)*2.2, 0)\n                .float('roughness', x/10)\n                .draw()\n         */\n        this.fw.frameEnd();\n      }\n      this.updateChart();\n      return requestAnimationFrame(this.update);\n    };\n\n    Application.prototype.on = function(name, callback) {\n      return this.hub.on(name, callback);\n    };\n\n    Application.prototype.emit = function(name, data) {\n      return this.hub.emit(name, data);\n    };\n\n    Application.prototype.doUpdateChart = function() {\n      var avgs;\n      avgs = this.accumulators.getAvg();\n      return this.chart.update(avgs);\n    };\n\n    Application.prototype.updateChart = function() {\n      if (this.lastChartUpdate != null) {\n        if (performance.now() - this.lastChartUpdate > 100) {\n          this.lastChartUpdate = performance.now();\n          return this.doUpdateChart();\n        }\n      } else {\n        this.lastChartUpdate = performance.now();\n        return this.doUpdateChart();\n      }\n    };\n\n    Application.prototype.save = function() {\n      var avgs, exposure, params, result, slice, _i, _len, _ref;\n      params = this.getParams();\n      exposure = Math.pow(2, params.exposure * 5);\n      result = [];\n      avgs = this.accumulators.getAvg();\n      _ref = this.accumulators.save(exposure);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        slice = _ref[_i];\n        result.push(compression.compress(slice));\n      }\n      result = JICKLE.encode(result);\n      return fileSystem.save(\"\" + this.environment.filename + \"-\" + (exposure.toFixed(2)) + \".env\", result);\n    };\n\n    return Application;\n\n  })();\n  $(function() {\n    var app;\n    return app = new Application();\n  });\n  display = function(data, size) {\n    var b, canvas, ctx, e, g, i, image, imageData, pixels, r, saturate, _i;\n    saturate = function(value) {\n      if (value < 0) {\n        return 0;\n      } else if (value > 1) {\n        return 1;\n      } else {\n        return value;\n      }\n    };\n    canvas = $('<canvas></canvas>').appendTo('body').css({\n      width: size,\n      height: size,\n      position: 'absolute',\n      backgroundColor: 'red',\n      zIndex: 1,\n      top: 0,\n      left: 0\n    })[0];\n    canvas.width = size;\n    canvas.height = size;\n    ctx = canvas.getContext('2d');\n    imageData = ctx.getImageData(0, 0, size, size);\n    image = imageData.data;\n    e = 1.0;\n    pixels = size * size;\n    for (i = _i = 0; 0 <= pixels ? _i < pixels : _i > pixels; i = 0 <= pixels ? ++_i : --_i) {\n      r = Math.round(saturate(data[i * 3 + 0] * e) * 255);\n      g = Math.round(saturate(data[i * 3 + 1] * e) * 255);\n      b = Math.round(saturate(data[i * 3 + 2] * e) * 255);\n      image[i * 4 + 0] = r;\n      image[i * 4 + 1] = g;\n      image[i * 4 + 2] = b;\n      image[i * 4 + 3] = 255;\n    }\n    return ctx.putImageData(imageData, 0, 0);\n  };\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/blit.shader":{"modified":1438771196934,"content":"sys.defFile(\"/webgl/blit.shader\", \"#file /webgl/blit.shader\\nvarying vec2 texcoord;\\n\\nvertex:\\n    attribute vec2 position;\\n    uniform vec2 viewport;\\n\\n    void main(){\\n        texcoord = position*0.5+0.5;\\n        gl_Position = vec4(position, 0, 1);\\n    }\\n\\nfragment:\\n    uniform sampler2D source;\\n    uniform float scale;\\n\\n    void main(){\\n        gl_FragColor.rgb = pow(texture2D(source, texcoord*scale).rgb, vec3(1.0/2.2));\\n        gl_FragColor.a = 1.0;\\n    }\");"},"/root/www/codeflow/webgl/envmapper3/src/webgl/framebuffer.coffee":{"modified":1438933773058,"content":"var __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nsys.defModule('/webgl/framebuffer', function(exports, require, fs) {\n  var Depthbuffer, Framebuffer, FramebufferCube, Renderbuffer, texture;\n  texture = require('texture');\n  exports.Framebuffer = Framebuffer = (function() {\n    function Framebuffer(gf, params) {\n      this.gf = gf;\n      if (params == null) {\n        params = {};\n      }\n      this.gl = this.gf.gl;\n      this.buffer = this.gl.createFramebuffer();\n    }\n\n    Framebuffer.prototype.generateMipmap = function() {\n      return this.colorTexture.generateMipmap();\n    };\n\n    Framebuffer.prototype.anisotropy = function() {\n      return this.colorTexture.anisotropy();\n    };\n\n    Framebuffer.prototype.bind = function(unit) {\n      if (unit == null) {\n        unit = 0;\n      }\n      return this.colorTexture.bind(unit);\n    };\n\n    Framebuffer.prototype.check = function() {\n      var result;\n      result = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);\n      switch (result) {\n        case this.gl.FRAMEBUFFER_UNSUPPORTED:\n          throw 'Framebuffer is unsupported';\n          break;\n        case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n          throw 'Framebuffer incomplete attachment';\n          break;\n        case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n          throw 'Framebuffer incomplete dimensions';\n          break;\n        case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n          throw 'Framebuffer incomplete missing attachment';\n      }\n      return this;\n    };\n\n    Framebuffer.prototype.unuse = function() {\n      if (this.gf.currentFramebuffer != null) {\n        this.gf.currentFramebuffer = null;\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      }\n      return this;\n    };\n\n    return Framebuffer;\n\n  })();\n  exports.Framebuffer2D = Framebuffer = (function(_super) {\n    __extends(Framebuffer, _super);\n\n    function Framebuffer(gf, params) {\n      this.gf = gf;\n      if (params == null) {\n        params = {};\n      }\n      Framebuffer.__super__.constructor.call(this, this.gf, params);\n      if (params.color != null) {\n        if (params.color instanceof texture.Texture) {\n          this.color(params.color);\n          this.ownColor = false;\n        } else {\n          this.color(this.gf.texture2D(params.color));\n          this.ownColor = true;\n        }\n      } else {\n        this.ownColor = false;\n      }\n      if (params.depth != null) {\n        this.depth(params.depth);\n      }\n    }\n\n    Framebuffer.prototype.color = function(colorTexture) {\n      this.colorTexture = colorTexture;\n      this.use();\n      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.colorTexture.target, this.colorTexture.handle, 0);\n      this.check();\n      this.unuse();\n      return this;\n    };\n\n    Framebuffer.prototype.depth = function(param) {\n      if (param instanceof exports.Depthbuffer) {\n        this.depthbuffer = param;\n      } else {\n        this.depthbuffer = new exports.Depthbuffer(this.gf);\n      }\n      if (this.colorTexture != null) {\n        this.depthbuffer.setSize(this.colorTexture.width, this.colorTexture.height);\n      } else {\n        throw Error('unimplemented');\n      }\n      this.use();\n      this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.depthbuffer.id);\n      this.check();\n      return this;\n    };\n\n    Framebuffer.prototype.use = function() {\n      if (this.gf.currentFramebuffer !== this) {\n        this.gf.currentFramebuffer = this;\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buffer);\n      }\n      return this;\n    };\n\n    Framebuffer.prototype.viewport = function(width, height) {\n      if (width == null) {\n        width = this.colorTexture.width;\n      }\n      if (height == null) {\n        height = this.colorTexture.height;\n      }\n      return this.gl.viewport(0, 0, width, height);\n    };\n\n    Framebuffer.prototype.destroy = function() {\n      this.gl.deleteFramebuffer(this.buffer);\n      if (this.ownColor) {\n        this.color.destroy();\n      }\n      if (this.depthbuffer != null) {\n        this.depthbuffer.destroy();\n      }\n      return this;\n    };\n\n    Framebuffer.prototype.setSize = function(width, height) {\n      if (this.colorTexture != null) {\n        this.colorTexture.size(width, height);\n      }\n      if (this.depthbuffer != null) {\n        return this.depthbuffer.setSize(width, height);\n      }\n    };\n\n    Framebuffer.prototype.width = function() {\n      if (this.colorTexture != null) {\n        return this.colorTexture.width;\n      } else if (this.depthbuffer) {\n        return this.depthbuffer.width;\n      } else {\n        throw Error('unimplemented');\n      }\n    };\n\n    Framebuffer.prototype.height = function() {\n      if (this.colorTexture != null) {\n        return this.colorTexture.height;\n      } else if (this.depthbuffer) {\n        return this.depthbuffer.height;\n      } else {\n        throw Error('unimplemented');\n      }\n    };\n\n    Framebuffer.prototype.blit = function() {\n      if (this.colorTexture != null) {\n        return this.colorTexture.draw();\n      } else {\n        throw Error('unimplemented');\n      }\n    };\n\n    Framebuffer.prototype.readPixels = function(x, y, width, height) {\n      var result, type;\n      if (x == null) {\n        x = 0;\n      }\n      if (y == null) {\n        y = 0;\n      }\n      if (width == null) {\n        width = this.colorTexture.width;\n      }\n      if (height == null) {\n        height = this.colorTexture.height;\n      }\n      type = this.colorTexture.type;\n      if (type === this.gl.UNSIGNED_BYTE) {\n        result = new Uint8Array(width * height * 4);\n      } else if (type = this.gl.FLOAT) {\n        result = new Float32Array(width * height * 4);\n      } else {\n        throw new Error('unsupported read type: ' + type);\n      }\n      this.use();\n      this.gl.readPixels(x, y, width, height, this.gl.RGBA, type, result);\n      return result;\n    };\n\n    Framebuffer.prototype.sizeEqual = function(width, height) {\n      if (width !== this.width()) {\n        return false;\n      }\n      if (height !== this.height()) {\n        return false;\n      }\n      return true;\n    };\n\n    return Framebuffer;\n\n  })(exports.Framebuffer);\n  exports.FramebufferCube = FramebufferCube = (function(_super) {\n    __extends(FramebufferCube, _super);\n\n    function FramebufferCube(gf, params) {\n      var color;\n      this.gf = gf;\n      FramebufferCube.__super__.constructor.call(this, this.gf, params);\n      this.negativeX = new exports.Framebuffer2D(this.gf);\n      this.negativeY = new exports.Framebuffer2D(this.gf);\n      this.negativeZ = new exports.Framebuffer2D(this.gf);\n      this.positiveX = new exports.Framebuffer2D(this.gf);\n      this.positiveY = new exports.Framebuffer2D(this.gf);\n      this.positiveZ = new exports.Framebuffer2D(this.gf);\n      this.currentSide = this.negativeX;\n      color = params.color;\n      if (color != null) {\n        if (params.color instanceof texture.Texture) {\n          this.color(params.color);\n        } else {\n          this.color(this.gf.textureCube(params.color));\n        }\n      }\n    }\n\n    FramebufferCube.prototype.color = function(colorTexture) {\n      this.colorTexture = colorTexture;\n      this.negativeX.color(this.colorTexture.negativeX);\n      this.negativeY.color(this.colorTexture.negativeY);\n      this.negativeZ.color(this.colorTexture.negativeZ);\n      this.positiveX.color(this.colorTexture.positiveX);\n      this.positiveY.color(this.colorTexture.positiveY);\n      return this.positiveZ.color(this.colorTexture.positiveZ);\n    };\n\n    FramebufferCube.prototype.destroy = function() {\n      this.negativeX.destroy();\n      this.negativeY.destroy();\n      this.negativeZ.destroy();\n      this.positiveX.destroy();\n      this.positiveY.destroy();\n      return this.positiveZ.destroy();\n    };\n\n    FramebufferCube.prototype.cubeSide = function(name) {\n      return this.currentSide = this[name];\n    };\n\n    FramebufferCube.prototype.use = function() {\n      return this.currentSide.use();\n    };\n\n    FramebufferCube.prototype.viewport = function(width, height) {\n      if (width == null) {\n        width = this.colorTexture.size;\n      }\n      if (height == null) {\n        height = this.colorTexture.size;\n      }\n      return this.gl.viewport(0, 0, width, height);\n    };\n\n    return FramebufferCube;\n\n  })(exports.Framebuffer);\n  exports.Renderbuffer = Renderbuffer = (function() {\n    function Renderbuffer(gf) {\n      this.gf = gf;\n      this.gl = this.gf.gl;\n      this.id = this.gl.createRenderbuffer();\n    }\n\n    Renderbuffer.prototype.bind = function() {\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.id);\n      return this;\n    };\n\n    Renderbuffer.prototype.setSize = function(width, height) {\n      this.width = width;\n      this.height = height;\n      this.bind();\n      this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl[this.format], this.width, this.height);\n      return this.unbind();\n    };\n\n    Renderbuffer.prototype.unbind = function() {\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      return this;\n    };\n\n    Renderbuffer.prototype.destroy = function() {\n      return this.gl.deleteRenderbuffer(this.id);\n    };\n\n    return Renderbuffer;\n\n  })();\n  exports.Depthbuffer = Depthbuffer = (function(_super) {\n    __extends(Depthbuffer, _super);\n\n    function Depthbuffer() {\n      return Depthbuffer.__super__.constructor.apply(this, arguments);\n    }\n\n    Depthbuffer.prototype.format = 'DEPTH_COMPONENT16';\n\n    return Depthbuffer;\n\n  })(Renderbuffer);\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/matrix.coffee":{"modified":1433162127578,"content":"sys.defModule('/webgl/matrix', function(exports, require, fs) {\n  var Mat3, Mat4, arc, deg, tau;\n  tau = Math.PI * 2;\n  deg = 360 / tau;\n  arc = tau / 360;\n  exports.Mat3 = Mat3 = (function() {\n    function Mat3(data) {\n      if (data == null) {\n        data = null;\n      }\n      this.data = data != null ? data : new Float32Array(9);\n      this.identity();\n    }\n\n    Mat3.prototype.identity = function() {\n      var d;\n      d = this.data;\n      d[0] = 1;\n      d[1] = 0;\n      d[2] = 0;\n      d[3] = 0;\n      d[4] = 1;\n      d[5] = 0;\n      d[6] = 0;\n      d[7] = 0;\n      d[8] = 1;\n      return this;\n    };\n\n    Mat3.prototype.value = function(value) {\n      var i, _i, _ref, _results;\n      _results = [];\n      for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        _results.push(this.data[i] = value);\n      }\n      return _results;\n    };\n\n    Mat3.prototype.rotatex = function(angle) {\n      var c, s;\n      s = Math.sin(angle * arc);\n      c = Math.cos(angle * arc);\n      return this.amul(1, 0, 0, 0, c, s, 0, -s, c);\n    };\n\n    Mat3.prototype.rotatey = function(angle) {\n      var c, s;\n      s = Math.sin(angle * arc);\n      c = Math.cos(angle * arc);\n      return this.amul(c, 0, -s, 0, 1, 0, s, 0, c);\n    };\n\n    Mat3.prototype.rotatez = function(angle) {\n      var c, s;\n      s = Math.sin(angle * arc);\n      c = Math.cos(angle * arc);\n      return this.amul(c, s, 0, -s, c, 0, 0, 0, 1);\n    };\n\n    Mat3.prototype.amul = function(b00, b10, b20, b01, b11, b21, b02, b12, b22, b03, b13, b23) {\n      var a, a00, a01, a02, a10, a11, a12, a20, a21, a22;\n      a = this.data;\n      a00 = a[0];\n      a10 = a[1];\n      a20 = a[2];\n      a01 = a[3];\n      a11 = a[4];\n      a21 = a[5];\n      a02 = a[6];\n      a12 = a[7];\n      a22 = a[8];\n      a[0] = a00 * b00 + a01 * b10 + a02 * b20;\n      a[1] = a10 * b00 + a11 * b10 + a12 * b20;\n      a[2] = a20 * b00 + a21 * b10 + a22 * b20;\n      a[3] = a00 * b01 + a01 * b11 + a02 * b21;\n      a[4] = a10 * b01 + a11 * b11 + a12 * b21;\n      a[5] = a20 * b01 + a21 * b11 + a22 * b21;\n      a[6] = a00 * b02 + a01 * b12 + a02 * b22;\n      a[7] = a10 * b02 + a11 * b12 + a12 * b22;\n      a[8] = a20 * b02 + a21 * b12 + a22 * b22;\n      return this;\n    };\n\n    Mat3.prototype.mulVec3 = function(vec, dst) {\n      if (dst == null) {\n        dst = vec;\n      }\n      this.mulVal3(vec.x, vec.y, vec.z, dst);\n      return dst;\n    };\n\n    Mat3.prototype.mulVal3 = function(x, y, z, dst) {\n      var d;\n      d = this.data;\n      dst.x = d[0] * x + d[3] * y + d[6] * z;\n      dst.y = d[1] * x + d[4] * y + d[7] * z;\n      dst.z = d[2] * x + d[5] * y + d[8] * z;\n      return this;\n    };\n\n    return Mat3;\n\n  })();\n  exports.Mat4 = Mat4 = (function() {\n    function Mat4(data) {\n      if (data != null) {\n        if (!data instanceof Float32Array) {\n          data = new Float32Array(data);\n        }\n        this.data = data;\n      } else {\n        this.data = new Float32Array(16);\n        this.identity();\n      }\n    }\n\n    Mat4.prototype.identity = function() {\n      var d;\n      d = this.data;\n      d[0] = 1;\n      d[1] = 0;\n      d[2] = 0;\n      d[3] = 0;\n      d[4] = 0;\n      d[5] = 1;\n      d[6] = 0;\n      d[7] = 0;\n      d[8] = 0;\n      d[9] = 0;\n      d[10] = 1;\n      d[11] = 0;\n      d[12] = 0;\n      d[13] = 0;\n      d[14] = 0;\n      d[15] = 1;\n      return this;\n    };\n\n    Mat4.prototype.value = function(value) {\n      var i, _i, _ref, _results;\n      _results = [];\n      for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        _results.push(this.data[i] = value);\n      }\n      return _results;\n    };\n\n    Mat4.prototype.zero = function() {\n      var d;\n      d = this.data;\n      d[0] = 0;\n      d[1] = 0;\n      d[2] = 0;\n      d[3] = 0;\n      d[4] = 0;\n      d[5] = 0;\n      d[6] = 0;\n      d[7] = 0;\n      d[8] = 0;\n      d[9] = 0;\n      d[10] = 0;\n      d[11] = 0;\n      d[12] = 0;\n      d[13] = 0;\n      d[14] = 0;\n      d[15] = 0;\n      return this;\n    };\n\n    Mat4.prototype.multiply = function(other) {\n      var a, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b, b0, b1, b2, b3, out;\n      b = this.data;\n      a = other.data;\n      out = b;\n      a00 = a[0];\n      a01 = a[1];\n      a02 = a[2];\n      a03 = a[3];\n      a10 = a[4];\n      a11 = a[5];\n      a12 = a[6];\n      a13 = a[7];\n      a20 = a[8];\n      a21 = a[9];\n      a22 = a[10];\n      a23 = a[11];\n      a30 = a[12];\n      a31 = a[13];\n      a32 = a[14];\n      a33 = a[15];\n      b0 = b[0];\n      b1 = b[1];\n      b2 = b[2];\n      b3 = b[3];\n      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n      b0 = b[4];\n      b1 = b[5];\n      b2 = b[6];\n      b3 = b[7];\n      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n      b0 = b[8];\n      b1 = b[9];\n      b2 = b[10];\n      b3 = b[11];\n      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n      b0 = b[12];\n      b1 = b[13];\n      b2 = b[14];\n      b3 = b[15];\n      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n      return this;\n    };\n\n    Mat4.prototype.transpose = function() {\n      var a, a01, a02, a03, a12, a13, a23, out;\n      a = out = this.data;\n      a01 = a[1];\n      a02 = a[2];\n      a03 = a[3];\n      a12 = a[6];\n      a13 = a[7];\n      a23 = a[11];\n      out[1] = a[4];\n      out[2] = a[8];\n      out[3] = a[12];\n      out[4] = a01;\n      out[6] = a[9];\n      out[7] = a[13];\n      out[8] = a02;\n      out[9] = a12;\n      out[11] = a[14];\n      out[12] = a03;\n      out[13] = a13;\n      out[14] = a23;\n      return this;\n    };\n\n    Mat4.prototype.copy = function(dest) {\n      var dst, src;\n      if (dest == null) {\n        dest = new Mat4();\n      }\n      src = this.data;\n      dst = dest.data;\n      dst[0] = src[0];\n      dst[1] = src[1];\n      dst[2] = src[2];\n      dst[3] = src[3];\n      dst[4] = src[4];\n      dst[5] = src[5];\n      dst[6] = src[6];\n      dst[7] = src[7];\n      dst[8] = src[8];\n      dst[9] = src[9];\n      dst[10] = src[10];\n      dst[11] = src[11];\n      dst[12] = src[12];\n      dst[13] = src[13];\n      dst[14] = src[14];\n      dst[15] = src[15];\n      return dest;\n    };\n\n\n    /*\n    perspective: (fov, aspect, near, far) ->\n        fov ?= 60\n        aspect ?= 1\n        near ?= 0.01\n        far ?= 100\n        \n         * diagonal fov\n        hyp = Math.sqrt(1 + aspect*aspect)\n        rel = 1/hyp\n        vfov = fov*rel\n        \n        @zero()\n        d = @data\n        top = near * Math.tan(vfov*Math.PI/360)\n        right = top*aspect\n        left = -right\n        bottom = -top\n        \n        d[0] = (2*near)/(right-left)\n        d[5] = (2*near)/(top-bottom)\n        d[8] = (right+left)/(right-left)\n        d[9] = (top+bottom)/(top-bottom)\n        d[10] = -(far+near)/(far-near)\n        d[11] = -1\n        d[14] = -(2*far*near)/(far-near)\n        \n        return @\n     */\n\n    Mat4.prototype.perspective = function(fov, aspect, near, far) {\n      var bottom, d, hyp, left, rel, right, top, vfov;\n      this.zero();\n      d = this.data;\n      hyp = Math.sqrt(1 + aspect * aspect);\n      rel = 1 / hyp;\n      vfov = fov * rel;\n      top = near * Math.tan(vfov * Math.PI / 360);\n      right = top * aspect;\n      left = -right;\n      bottom = -top;\n      d[0] = (2 * near) / (right - left);\n      d[5] = (2 * near) / (top - bottom);\n      d[8] = (right + left) / (right - left);\n      d[9] = (top + bottom) / (top - bottom);\n      d[10] = -(far + near) / (far - near);\n      d[11] = -1;\n      d[14] = -(2 * far * near) / (far - near);\n      return this;\n    };\n\n    Mat4.prototype.inversePerspective = function(fov, aspect, near, far) {\n      var bottom, dst, hyp, left, rel, right, top, vfov;\n      this.zero();\n      dst = this.data;\n      hyp = Math.sqrt(1 + aspect * aspect);\n      rel = 1 / hyp;\n      vfov = fov * rel;\n      top = near * Math.tan(vfov * Math.PI / 360);\n      right = top * aspect;\n      left = -right;\n      bottom = -top;\n      dst[0] = (right - left) / (2 * near);\n      dst[5] = (top - bottom) / (2 * near);\n      dst[11] = -(far - near) / (2 * far * near);\n      dst[12] = (right + left) / (2 * near);\n      dst[13] = (top + bottom) / (2 * near);\n      dst[14] = -1;\n      dst[15] = (far + near) / (2 * far * near);\n      return this;\n    };\n\n    Mat4.prototype.ortho = function(near, far, top, bottom, left, right) {\n      var fn, rl, tb;\n      if (near == null) {\n        near = -1;\n      }\n      if (far == null) {\n        far = 1;\n      }\n      if (top == null) {\n        top = -1;\n      }\n      if (bottom == null) {\n        bottom = 1;\n      }\n      if (left == null) {\n        left = -1;\n      }\n      if (right == null) {\n        right = 1;\n      }\n      rl = right - left;\n      tb = top - bottom;\n      fn = far - near;\n      return this.set(2 / rl, 0, 0, -(left + right) / rl, 0, 2 / tb, 0, -(top + bottom) / tb, 0, 0, -2 / fn, -(far + near) / fn, 0, 0, 0, 1);\n    };\n\n    Mat4.prototype.inverseOrtho = function(near, far, top, bottom, left, right) {\n      var a, b, c, d, e, f, g;\n      if (near == null) {\n        near = -1;\n      }\n      if (far == null) {\n        far = 1;\n      }\n      if (top == null) {\n        top = -1;\n      }\n      if (bottom == null) {\n        bottom = 1;\n      }\n      if (left == null) {\n        left = -1;\n      }\n      if (right == null) {\n        right = 1;\n      }\n      a = (right - left) / 2;\n      b = (right + left) / 2;\n      c = (top - bottom) / 2;\n      d = (top + bottom) / 2;\n      e = (far - near) / -2;\n      f = (near + far) / 2;\n      g = 1;\n      return this.set(a, 0, 0, b, 0, c, 0, d, 0, 0, e, f, 0, 0, 0, g);\n    };\n\n    Mat4.prototype.translate = function(x, y, z) {\n      var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, d;\n      d = this.data;\n      a00 = d[0];\n      a01 = d[1];\n      a02 = d[2];\n      a03 = d[3];\n      a10 = d[4];\n      a11 = d[5];\n      a12 = d[6];\n      a13 = d[7];\n      a20 = d[8];\n      a21 = d[9];\n      a22 = d[10];\n      a23 = d[11];\n      d[12] = a00 * x + a10 * y + a20 * z + d[12];\n      d[13] = a01 * x + a11 * y + a21 * z + d[13];\n      d[14] = a02 * x + a12 * y + a22 * z + d[14];\n      d[15] = a03 * x + a13 * y + a23 * z + d[15];\n      return this;\n    };\n\n    Mat4.prototype.scale = function(x, y, z) {\n      var d;\n      d = this.data;\n      d[0] = d[0] * x;\n      d[1] = d[1] * x;\n      d[2] = d[2] * x;\n      d[3] = d[3] * x;\n      d[4] = d[4] * y;\n      d[5] = d[5] * y;\n      d[6] = d[6] * y;\n      d[7] = d[7] * y;\n      d[8] = d[8] * z;\n      d[9] = d[9] * z;\n      d[10] = d[10] * z;\n      d[11] = d[11] * z;\n      return this;\n    };\n\n    Mat4.prototype.rotatex = function(angle) {\n      var a10, a11, a12, a13, a20, a21, a22, a23, c, d, rad, s;\n      d = this.data;\n      rad = tau * (angle / 360);\n      s = Math.sin(rad);\n      c = Math.cos(rad);\n      a10 = d[4];\n      a11 = d[5];\n      a12 = d[6];\n      a13 = d[7];\n      a20 = d[8];\n      a21 = d[9];\n      a22 = d[10];\n      a23 = d[11];\n      d[4] = a10 * c + a20 * s;\n      d[5] = a11 * c + a21 * s;\n      d[6] = a12 * c + a22 * s;\n      d[7] = a13 * c + a23 * s;\n      d[8] = a10 * -s + a20 * c;\n      d[9] = a11 * -s + a21 * c;\n      d[10] = a12 * -s + a22 * c;\n      d[11] = a13 * -s + a23 * c;\n      return this;\n    };\n\n    Mat4.prototype.rotatey = function(angle) {\n      var a00, a01, a02, a03, a20, a21, a22, a23, c, d, rad, s;\n      d = this.data;\n      rad = tau * (angle / 360);\n      s = Math.sin(rad);\n      c = Math.cos(rad);\n      a00 = d[0];\n      a01 = d[1];\n      a02 = d[2];\n      a03 = d[3];\n      a20 = d[8];\n      a21 = d[9];\n      a22 = d[10];\n      a23 = d[11];\n      d[0] = a00 * c + a20 * -s;\n      d[1] = a01 * c + a21 * -s;\n      d[2] = a02 * c + a22 * -s;\n      d[3] = a03 * c + a23 * -s;\n      d[8] = a00 * s + a20 * c;\n      d[9] = a01 * s + a21 * c;\n      d[10] = a02 * s + a22 * c;\n      d[11] = a03 * s + a23 * c;\n      return this;\n    };\n\n    Mat4.prototype.rotatez = function(angle) {\n      var a00, a01, a02, a03, a10, a11, a12, a13, c, d, rad, s;\n      d = this.data;\n      rad = tau * (angle / 360);\n      s = Math.sin(rad);\n      c = Math.cos(rad);\n      a00 = d[0];\n      a01 = d[1];\n      a02 = d[2];\n      a03 = d[3];\n      a10 = d[4];\n      a11 = d[5];\n      a12 = d[6];\n      a13 = d[7];\n      d[0] = a00 * c + a10 * s;\n      d[1] = a01 * c + a11 * s;\n      d[2] = a02 * c + a12 * s;\n      d[3] = a03 * c + a13 * s;\n      d[4] = a10 * c - a00 * s;\n      d[5] = a11 * c - a01 * s;\n      d[6] = a12 * c - a02 * s;\n      d[7] = a13 * c - a03 * s;\n      return this;\n    };\n\n    Mat4.prototype.invert = function(destination) {\n      var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, a30, a31, a32, a33, b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11, d, dst, invDet, src;\n      if (destination == null) {\n        destination = this;\n      }\n      src = this.data;\n      dst = destination.data;\n      a00 = src[0];\n      a01 = src[1];\n      a02 = src[2];\n      a03 = src[3];\n      a10 = src[4];\n      a11 = src[5];\n      a12 = src[6];\n      a13 = src[7];\n      a20 = src[8];\n      a21 = src[9];\n      a22 = src[10];\n      a23 = src[11];\n      a30 = src[12];\n      a31 = src[13];\n      a32 = src[14];\n      a33 = src[15];\n      b00 = a00 * a11 - a01 * a10;\n      b01 = a00 * a12 - a02 * a10;\n      b02 = a00 * a13 - a03 * a10;\n      b03 = a01 * a12 - a02 * a11;\n      b04 = a01 * a13 - a03 * a11;\n      b05 = a02 * a13 - a03 * a12;\n      b06 = a20 * a31 - a21 * a30;\n      b07 = a20 * a32 - a22 * a30;\n      b08 = a20 * a33 - a23 * a30;\n      b09 = a21 * a32 - a22 * a31;\n      b10 = a21 * a33 - a23 * a31;\n      b11 = a22 * a33 - a23 * a32;\n      d = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n      if (d === 0) {\n        return;\n      }\n      invDet = 1 / d;\n      dst[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n      dst[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n      dst[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n      dst[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n      dst[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n      dst[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n      dst[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n      dst[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n      dst[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n      dst[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n      dst[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n      dst[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n      dst[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n      dst[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n      dst[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n      dst[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n      return destination;\n    };\n\n    Mat4.prototype.toMat3Rot = function(dest) {\n      var a00, a01, a02, a10, a11, a12, a20, a21, a22, b01, b11, b21, d, dst, id, src;\n      dst = dest.data;\n      src = this.data;\n      a00 = src[0];\n      a01 = src[1];\n      a02 = src[2];\n      a10 = src[4];\n      a11 = src[5];\n      a12 = src[6];\n      a20 = src[8];\n      a21 = src[9];\n      a22 = src[10];\n      b01 = a22 * a11 - a12 * a21;\n      b11 = -a22 * a10 + a12 * a20;\n      b21 = a21 * a10 - a11 * a20;\n      d = a00 * b01 + a01 * b11 + a02 * b21;\n      id = 1 / d;\n      dst[0] = b01 * id;\n      dst[3] = (-a22 * a01 + a02 * a21) * id;\n      dst[6] = (a12 * a01 - a02 * a11) * id;\n      dst[1] = b11 * id;\n      dst[4] = (a22 * a00 - a02 * a20) * id;\n      dst[7] = (-a12 * a00 + a02 * a10) * id;\n      dst[2] = b21 * id;\n      dst[5] = (-a21 * a00 + a01 * a20) * id;\n      dst[8] = (a11 * a00 - a01 * a10) * id;\n      return this;\n    };\n\n    Mat4.prototype.set = function(a00, a10, a20, a30, a01, a11, a21, a31, a02, a12, a22, a32, a03, a13, a23, a33) {\n      var d;\n      d = this.data;\n      d[0] = a00;\n      d[4] = a10;\n      d[8] = a20;\n      d[12] = a30;\n      d[1] = a01;\n      d[5] = a11;\n      d[9] = a21;\n      d[13] = a31;\n      d[2] = a02;\n      d[6] = a12;\n      d[10] = a22;\n      d[14] = a32;\n      d[3] = a03;\n      d[7] = a13;\n      d[11] = a23;\n      d[15] = a33;\n      return this;\n    };\n\n    Mat4.prototype.mulVec3 = function(vec, dst) {\n      if (dst == null) {\n        dst = vec;\n      }\n      return this.mulVal3(vec.x, vec.y, vec.z, dst);\n    };\n\n    Mat4.prototype.mulVal3 = function(x, y, z, dst) {\n      var d;\n      d = this.data;\n      dst.x = d[0] * x + d[4] * y + d[8] * z;\n      dst.y = d[1] * x + d[5] * y + d[9] * z;\n      dst.z = d[2] * x + d[6] * y + d[10] * z;\n      return dst;\n    };\n\n    Mat4.prototype.mulVec4 = function(vec, dst) {\n      if (dst == null) {\n        dst = vec;\n      }\n      return this.mulVal4(vec[0], vec[1], vec[2], vec[3], dst);\n    };\n\n    Mat4.prototype.mulVal4 = function(x, y, z, w, dst) {\n      var d;\n      d = this.data;\n      dst.x = d[0] * x + d[4] * y + d[8] * z + d[12] * w;\n      dst.y = d[1] * x + d[5] * y + d[9] * z + d[13] * w;\n      dst.z = d[2] * x + d[6] * y + d[10] * z + d[14] * w;\n      dst.w = d[3] * x + d[7] * y + d[11] * z + d[15] * w;\n      return dst;\n    };\n\n    return Mat4;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/module.coffee":{"modified":1438933424774,"content":"var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nsys.defModule('/webgl/module', function(exports, require, fs) {\n  var Shader, ShaderProxy, State, VertexBuffer, WebGLFramework, framebuffer, getExtension, getSupportedExtensions, matrix, shims, texture, textureFloat, vector, vendorRe, vendors, _ref;\n  if (window.WebGLRenderingContext != null) {\n    vendors = ['WEBKIT', 'MOZ', 'MS', 'O'];\n    vendorRe = /^WEBKIT_(.*)|MOZ_(.*)|MS_(.*)|O_(.*)/;\n    getExtension = WebGLRenderingContext.prototype.getExtension;\n    WebGLRenderingContext.prototype.getExtension = function(name) {\n      var extobj, match, vendor, _i, _len;\n      match = name.match(vendorRe);\n      if (match !== null) {\n        name = match[1];\n      }\n      extobj = getExtension.call(this, name);\n      if (extobj === null) {\n        for (_i = 0, _len = vendors.length; _i < _len; _i++) {\n          vendor = vendors[_i];\n          extobj = getExtension.call(this, vendor + '_' + name);\n          if (extobj !== null) {\n            return extobj;\n          }\n        }\n        return null;\n      } else {\n        return extobj;\n      }\n    };\n    getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions;\n    WebGLRenderingContext.prototype.getSupportedExtensions = function() {\n      var extension, match, result, supported, _i, _len;\n      supported = getSupportedExtensions.call(this);\n      result = [];\n      for (_i = 0, _len = supported.length; _i < _len; _i++) {\n        extension = supported[_i];\n        match = extension.match(vendorRe);\n        if (match !== null) {\n          extension = match[1];\n        }\n        if (__indexOf.call(result, extension) < 0) {\n          result.push(extension);\n        }\n      }\n      return result;\n    };\n  }\n  shims = require('shims');\n  textureFloat = require('texture-float');\n  texture = require('texture');\n  matrix = require('matrix');\n  vector = require('vector');\n  State = require('state');\n  VertexBuffer = require('vertexbuffer').VertexBuffer;\n  _ref = require('shader'), Shader = _ref.Shader, ShaderProxy = _ref.ShaderProxy;\n  framebuffer = require('framebuffer');\n  exports = WebGLFramework = (function() {\n    function WebGLFramework(params) {\n      var debug, float16, float32, i, perf, _ref1, _ref2, _ref3;\n      if (params == null) {\n        params = {};\n      }\n      debug = (_ref1 = params.debug) != null ? _ref1 : false;\n      delete params.debug;\n      perf = (_ref2 = params.perf) != null ? _ref2 : false;\n      delete params.perf;\n      this.canvas = (_ref3 = params.canvas) != null ? _ref3 : document.createElement('canvas');\n      delete params.canvas;\n      this.gl = this.getContext('webgl', params);\n      this.gl.getExtension('OES_standard_derivatives');\n      if (this.gl == null) {\n        this.gl = this.getContext('experimental-webgl');\n      }\n      if (this.gl == null) {\n        throw new Error('WebGL is not supported');\n      }\n      this.textureFloat = textureFloat(this.gl);\n      float32 = this.textureFloat.float32;\n      float16 = this.textureFloat.float16;\n      if (float32.renderable && float32.linear) {\n        this.usableFloat = float32.type;\n      } else if (float16.renderable && float16.linear) {\n        this.usableFloat = float16.type;\n      }\n      this.vao = null;\n      if ((window.WebGLPerfContext != null) && perf) {\n        console.log('webgl perf context enabled');\n        this.gl = new WebGLPerfContext.create(this.gl);\n      } else if ((window.WebGLDebugUtils != null) && debug) {\n        console.log('webgl debug enabled');\n        this.gl = WebGLDebugUtils.makeDebugContext(this.gl, function(err, funcName, args) {\n          throw WebGLDebugUtils.glEnumToString(err) + \" was caused by call to: \" + funcName;\n        });\n      }\n      this.currentVertexBuffer = null;\n      this.currentShader = null;\n      this.currentFramebuffer = null;\n      this.currentState = null;\n      this.maxAttribs = this.gl.getParameter(this.gl.MAX_VERTEX_ATTRIBS);\n      this.vertexUnits = (function() {\n        var _i, _ref4, _results;\n        _results = [];\n        for (i = _i = 0, _ref4 = this.maxAttribs; 0 <= _ref4 ? _i < _ref4 : _i > _ref4; i = 0 <= _ref4 ? ++_i : --_i) {\n          _results.push({\n            enabled: false,\n            pointer: null,\n            location: i\n          });\n        }\n        return _results;\n      }).call(this);\n      this.textureUnits = (function() {\n        var _i, _results;\n        _results = [];\n        for (i = _i = 0; _i < 16; i = ++_i) {\n          _results.push(null);\n        }\n        return _results;\n      })();\n      this.lineWidth = 1;\n      this.quadVertices = this.vertexbuffer({\n        pointers: [\n          {\n            name: 'position',\n            size: 2\n          }\n        ],\n        vertices: [-1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1, 1]\n      });\n      this.blit = this.state({\n        shader: fs.open('blit.shader')\n      });\n      this.readFBO = this.framebuffer();\n    }\n\n    WebGLFramework.prototype.haveExtension = function(search) {\n      var name, _i, _len, _ref1;\n      _ref1 = this.gl.getSupportedExtensions();\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        name = _ref1[_i];\n        if (name.indexOf(search) >= 0) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    WebGLFramework.prototype.getContext = function(name, params) {\n      var error;\n      try {\n        return this.canvas.getContext(name, params);\n      } catch (_error) {\n        error = _error;\n        return null;\n      }\n    };\n\n    WebGLFramework.prototype.state = function(params) {\n      return new State(this, params);\n    };\n\n    WebGLFramework.prototype.vertexbuffer = function(params) {\n      return new VertexBuffer(this, params);\n    };\n\n    WebGLFramework.prototype.framebuffer = function(params) {\n      if (params == null) {\n        params = {};\n      }\n      if (params.type != null) {\n        if (params.type === '2d') {\n          return new framebuffer.Framebuffer2D(this, params);\n        } else if (params.type === 'cube') {\n          return new framebuffer.FramebufferCube(this, params);\n        } else {\n          throw new Error('unknown framebuffer type: ' + params.type);\n        }\n      } else {\n        return new framebuffer.Framebuffer2D(this, params);\n      }\n    };\n\n    WebGLFramework.prototype.depthbuffer = function(params) {\n      return new framebuffer.Depthbuffer(this, params);\n    };\n\n    WebGLFramework.prototype.shader = function(params) {\n      return new Shader(this, params);\n    };\n\n    WebGLFramework.prototype.shaderProxy = function(shader) {\n      return new ShaderProxy(shader);\n    };\n\n    WebGLFramework.prototype.mat4 = function(view) {\n      return new matrix.Mat4(view);\n    };\n\n    WebGLFramework.prototype.mat3 = function(view) {\n      return new matrix.Mat3(view);\n    };\n\n    WebGLFramework.prototype.vec3 = function(x, y, z) {\n      return new vector.Vec3(x, y, z);\n    };\n\n    WebGLFramework.prototype.vec4 = function(x, y, z, w) {\n      return new vector.Vec4(x, y, z, w);\n    };\n\n    WebGLFramework.prototype.clearColor = function(r, g, b, a) {\n      this.gl.clearColor(r, g, b, a);\n      this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n      return this;\n    };\n\n    WebGLFramework.prototype.frameStart = function() {\n      var factor;\n      factor = 1;\n      if (this.canvas.offsetWidth * factor !== this.canvas.width) {\n        this.canvas.width = this.canvas.offsetWidth * factor;\n      }\n      if (this.canvas.offsetHeight * factor !== this.canvas.height) {\n        this.canvas.height = this.canvas.offsetHeight * factor;\n      }\n      if (this.gl.performance != null) {\n        this.gl.performance.start();\n      }\n      return this;\n    };\n\n    WebGLFramework.prototype.frameEnd = function() {\n      if (this.gl.performance != null) {\n        this.gl.performance.stop();\n      }\n      return this;\n    };\n\n    WebGLFramework.prototype.texture2D = function(params) {\n      return new texture.Texture2D(this, params);\n    };\n\n    WebGLFramework.prototype.textureCube = function(params) {\n      return new texture.TextureCube(this, params);\n    };\n\n    WebGLFramework.prototype.getExtension = function(name) {\n      return this.gl.getExtension(name);\n    };\n\n    WebGLFramework.prototype.htmlColor2Vec = function(value) {\n      var b, g, r;\n      r = parseInt(value.slice(0, 2), 16) / 255;\n      g = parseInt(value.slice(2, 4), 16) / 255;\n      b = parseInt(value.slice(4), 16) / 255;\n      return {\n        r: r,\n        g: g,\n        b: b\n      };\n    };\n\n    return WebGLFramework;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/shader.coffee":{"modified":1444893710138,"content":"var __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nsys.defModule('/webgl/shader', function(exports, require, fs) {\n  var Shader, ShaderObj, ShaderProxy, Vec3, Vec4, boilerplate, matrix, _ref;\n  matrix = require('matrix');\n  _ref = require('vector'), Vec3 = _ref.Vec3, Vec4 = _ref.Vec4;\n  exports.ShaderObj = ShaderObj = (function() {\n    function ShaderObj() {}\n\n    return ShaderObj;\n\n  })();\n  boilerplate = '    #extension GL_OES_standard_derivatives : enable\\n\\n    precision highp int;\\n    precision highp float;\\n    #define PI 3.141592653589793\\n    #define TAU 6.283185307179586\\n    #define PIH 1.5707963267948966\\n    #define E 2.7182818284590451\\n    #define logN(x, base) (log(x)/log(base))\\n    float angleBetween(vec3 a, vec3 b){return acos(dot(a,b));}\\n\\n    vec3 gammasRGB(vec3 color){\\n        return mix(\\n            color*12.92,\\n            pow(color, vec3(1.0/2.4))*1.055-0.055,\\n            step((0.04045/12.92), color)\\n        );\\n    }\\n\\n    vec3 degammasRGB(vec3 color){\\n        return mix(\\n            color/12.92,\\n            pow((color+0.055)/1.055, vec3(2.4)),\\n            step(0.04045, color)\\n        );\\n    }\\n\\n    vec3 gamma(vec3 color){\\n        //return gammasRGB(color);\\n        return pow(color, vec3(1.0/2.2));\\n    }\\n\\n    vec3 degamma(vec3 color){\\n        //return degammasRGB(color);\\n        return pow(color, vec3(2.2));\\n    }\\n    \\n    float linstep(float edge0, float edge1, float value){\\n        return clamp((value-edge0)/(edge1-edge0), 0.0, 1.0);\\n    }\\n    \\n    float linstepOpen(float edge0, float edge1, float value){\\n        return (value-edge0)/(edge1-edge0);\\n    }\\n\\n    vec2 linstep(vec2 edge0, vec2 edge1, vec2 value){\\n        return clamp((value-edge0)/(edge1-edge0), vec2(0.0), vec2(1.0));\\n    }\\n    \\n    vec2 linstepOpen(vec2 edge0, vec2 edge1, vec2 value){\\n        return (value-edge0)/(edge1-edge0);\\n    }\\n\\n    float pyramidstep(float edge0, float edge1, float value){\\n        float f = (value-edge0)/(edge1-edge0);\\n        return clamp(abs(f*2.0-1.0), 0.0, 1.0);\\n    }\\n    \\n    vec2 pyramidstep(vec2 edge0, vec2 edge1, vec2 value){\\n        vec2 f = (value-edge0)/(edge1-edge0);\\n        return abs(f*2.0-1.0);\\n    }\\n    \\n    vec3 pyramidstep(vec3 edge0, vec3 edge1, vec3 value){\\n        vec3 f = (value-edge0)/(edge1-edge0);\\n        return abs(f*2.0-1.0);\\n    }\\n    \\n    vec2 encodeNormal(vec3 n){\\n        float f = sqrt(8.0*n.z+8.0);\\n        return n.xy / f + 0.5;\\n    }\\n\\n    vec3 decodeNormal(vec2 enc){\\n        vec2 fenc = enc*4.0-2.0;\\n        float f = dot(fenc,fenc);\\n        float g = sqrt(1.0-f/4.0);\\n        return vec3(\\n            fenc*g,\\n            1.0-f/2.0\\n        );\\n    }\\n\\n    vec2 pack16(float value){\\n        float sMax = 65535.0;\\n        int v = int(clamp(value, 0.0, 1.0)*sMax+0.5);\\n        int digit0 = v/256;\\n        int digit1 = v-digit0*256;\\n        return vec2(float(digit0)/255.0, float(digit1)/255.0);\\n    }\\n\\n    vec2 pack16(int v){\\n        int digit0 = v/256;\\n        int digit1 = v-digit0*256;\\n        return vec2(float(digit0)/255.0, float(digit1)/255.0);\\n    }\\n\\n    float unpack16(vec2 value){\\n        return (\\n            value.x*0.996108949416342426275150501169264316558837890625 +\\n            value.y*0.00389105058365758760263730664519243873655796051025390625\\n        );\\n    }';\n  exports.Shader = Shader = (function(_super) {\n    __extends(Shader, _super);\n\n    function Shader(gf, params) {\n      this.gf = gf;\n      this.gl = this.gf.gl;\n      this.program = this.gl.createProgram();\n      this.vs = this.gl.createShader(this.gl.VERTEX_SHADER);\n      this.fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n      this.gl.attachShader(this.program, this.vs);\n      this.gl.attachShader(this.program, this.fs);\n      this.source(params);\n    }\n\n    Shader.prototype.source = function(params) {\n      var c, common, f, file, fragment, v, vertex, _i, _len, _ref1, _ref2, _ref3;\n      if (typeof params === 'string') {\n        _ref1 = this.splitSource(params), common = _ref1[0], vertex = _ref1[1], fragment = _ref1[2];\n      } else if (params instanceof sys.File) {\n        _ref2 = this.splitSource(params.read()), common = _ref2[0], vertex = _ref2[1], fragment = _ref2[2];\n      } else if (params instanceof Array) {\n        common = [];\n        vertex = [];\n        fragment = [];\n        for (_i = 0, _len = params.length; _i < _len; _i++) {\n          file = params[_i];\n          _ref3 = this.splitSource(file.read()), c = _ref3[0], v = _ref3[1], f = _ref3[2];\n          if (c.length > 0) {\n            common.push(c);\n          }\n          if (v.length > 0) {\n            vertex.push(v);\n          }\n          if (f.length > 0) {\n            fragment.push(f);\n          }\n        }\n        common = common.join('\\n');\n        vertex = vertex.join('\\n');\n        fragment = fragment.join('\\n');\n      }\n      return this.setSource({\n        common: common,\n        vertex: vertex,\n        fragment: fragment\n      });\n    };\n\n    Shader.prototype.destroy = function() {\n      this.gl.deleteShader(this.vs);\n      this.gl.deleteShader(this.fs);\n      return this.gl.deleteProgram(this.program);\n    };\n\n    Shader.prototype.splitSource = function(source) {\n      var common, current, filename, fragment, line, linenum, lines, vertex, _i, _len;\n      common = [];\n      vertex = [];\n      fragment = [];\n      current = common;\n      lines = source.trim().split('\\n');\n      filename = lines.shift().split(' ')[1];\n      for (linenum = _i = 0, _len = lines.length; _i < _len; linenum = ++_i) {\n        line = lines[linenum];\n        if (line.match(/vertex:$/)) {\n          current = vertex;\n        } else if (line.match(/fragment:$/)) {\n          current = fragment;\n        } else {\n          current.push(\"#line \" + linenum + \" \" + filename);\n          current.push(line);\n        }\n      }\n      return [common.join('\\n').trim(), vertex.join('\\n').trim(), fragment.join('\\n').trim()];\n    };\n\n    Shader.prototype.preprocess = function(source) {\n      var filename, line, lineno, lines, match, result, _i, _len, _ref1;\n      lines = [];\n      result = [];\n      filename = 'no file';\n      lineno = 1;\n      _ref1 = source.trim().split('\\n');\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        line = _ref1[_i];\n        match = line.match(/#line (\\d+) (.*)/);\n        if (match) {\n          lineno = parseInt(match[1], 10) + 1;\n          filename = match[2];\n        } else {\n          lines.push({\n            source: line,\n            lineno: lineno,\n            filename: filename\n          });\n          result.push(line);\n          lineno += 1;\n        }\n      }\n      return [result.join('\\n'), lines];\n    };\n\n    Shader.prototype.setSource = function(_arg) {\n      var common, fragment, vertex;\n      common = _arg.common, vertex = _arg.vertex, fragment = _arg.fragment;\n      this.uniformCache = {};\n      this.attributeCache = {};\n      if (common == null) {\n        common = '';\n      }\n      this.compileShader(this.vs, [common, vertex].join('\\n'));\n      this.compileShader(this.fs, [common, fragment].join('\\n'));\n      return this.link();\n    };\n\n    Shader.prototype.compileShader = function(shader, source) {\n      var error, lines, _ref1;\n      source = [boilerplate, source].join('\\n');\n      _ref1 = this.preprocess(source), source = _ref1[0], lines = _ref1[1];\n      this.gl.shaderSource(shader, source);\n      this.gl.compileShader(shader);\n      if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n        error = this.gl.getShaderInfoLog(shader);\n        throw this.translateError(error, lines);\n      }\n    };\n\n    Shader.prototype.link = function() {\n      this.gl.linkProgram(this.program);\n      if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n        throw new Error(\"Shader Link Error: \" + (this.gl.getProgramInfoLog(this.program)));\n      }\n    };\n\n    Shader.prototype.translateError = function(error, lines) {\n      var i, line, lineno, match, message, result, sourceline, _i, _len, _ref1;\n      result = ['Shader Compile Error'];\n      _ref1 = error.split('\\n');\n      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\n        line = _ref1[i];\n        match = line.match(/ERROR: \\d+:(\\d+): (.*)/);\n        if (match) {\n          lineno = parseFloat(match[1]) - 1;\n          message = match[2];\n          sourceline = lines[lineno];\n          result.push(\"File \\\"\" + sourceline.filename + \"\\\", Line \" + sourceline.lineno + \", \" + message);\n          result.push(\"   \" + sourceline.source);\n        } else {\n          result.push(line);\n        }\n      }\n      return result.join('\\n');\n    };\n\n    Shader.prototype.attributeLocation = function(name, index) {\n      var location;\n      if (index != null) {\n        this.attributeCache[name] = index;\n        this.gl.bindAttribLocation(this.program, index, name);\n        return index;\n      } else {\n        location = this.attributeCache[name];\n        if (location === void 0) {\n          location = this.gl.getAttribLocation(this.program, name);\n          if (location >= 0) {\n            this.attributeCache[name] = location;\n            return location;\n          } else {\n            this.attributeCache[name] = null;\n            return null;\n          }\n        } else {\n          return location;\n        }\n      }\n    };\n\n    Shader.prototype.uniformLocation = function(name) {\n      var location;\n      location = this.uniformCache[name];\n      if (location === void 0) {\n        location = this.gl.getUniformLocation(this.program, name);\n        if (location != null) {\n          this.uniformCache[name] = location;\n          return location;\n        } else {\n          this.uniformCache[name] = null;\n          return null;\n        }\n      } else {\n        return location;\n      }\n    };\n\n    Shader.prototype.use = function() {\n      if (this.gf.currentShader !== this) {\n        this.gf.currentShader = this;\n        return this.gl.useProgram(this.program);\n      }\n    };\n\n    Shader.prototype.mat4 = function(name, value) {\n      var location;\n      if (value instanceof matrix.Mat4) {\n        value = value.data;\n      }\n      location = this.uniformLocation(name);\n      if (location != null) {\n        this.use();\n        this.gl.uniformMatrix4fv(location, false, value);\n      }\n      return this;\n    };\n\n    Shader.prototype.mat3 = function(name, value) {\n      var location;\n      if (value instanceof matrix.Mat3) {\n        value = value.data;\n      }\n      location = this.uniformLocation(name);\n      if (location != null) {\n        this.use();\n        this.gl.uniformMatrix3fv(location, false, value);\n      }\n      return this;\n    };\n\n    Shader.prototype.vec2 = function(name, a, b) {\n      var location;\n      location = this.uniformLocation(name);\n      if (location != null) {\n        this.use();\n        if (a instanceof Array || a instanceof Float32Array) {\n          this.gl.uniform2fv(location, a);\n        } else {\n          this.gl.uniform2f(location, a, b);\n        }\n      }\n      return this;\n    };\n\n    Shader.prototype.vec3 = function(name, a, b, c) {\n      var location;\n      location = this.uniformLocation(name);\n      if (location != null) {\n        this.use();\n        if (a instanceof Array || a instanceof Float32Array) {\n          this.gl.uniform3fv(location, a);\n        } else if (a instanceof Vec3) {\n          this.gl.uniform3f(location, a.x, a.y, a.z);\n        } else {\n          this.gl.uniform3f(location, a, b, c);\n        }\n      }\n      return this;\n    };\n\n    Shader.prototype.vec4 = function(name, a, b, c, d) {\n      var location;\n      location = this.uniformLocation(name);\n      if (location != null) {\n        this.use();\n        if (a instanceof Array || a instanceof Float32Array) {\n          this.gl.uniform4fv(location, a);\n        } else {\n          this.gl.uniform4f(location, a, b, c, d);\n        }\n      }\n      return this;\n    };\n\n    Shader.prototype.int = function(name, value) {\n      var location;\n      location = this.uniformLocation(name);\n      if (location != null) {\n        this.use();\n        this.gl.uniform1i(location, value);\n      }\n      return this;\n    };\n\n    Shader.prototype.uniformSetter = function(obj) {\n      obj.setUniformsOn(this);\n      return this;\n    };\n\n    Shader.prototype.float = function(name, value) {\n      var location;\n      location = this.uniformLocation(name);\n      if (location != null) {\n        this.use();\n        if (value instanceof Array || value instanceof Float32Array) {\n          this.gl.uniform1fv(location, value);\n        } else {\n          this.gl.uniform1f(location, value);\n        }\n      }\n      return this;\n    };\n\n    return Shader;\n\n  })(ShaderObj);\n  exports.ShaderProxy = ShaderProxy = (function(_super) {\n    __extends(ShaderProxy, _super);\n\n    function ShaderProxy(shader) {\n      this.shader = shader != null ? shader : null;\n    }\n\n    ShaderProxy.prototype.attributeLocation = function(name) {\n      return this.shader.attributeLocation(name);\n    };\n\n    ShaderProxy.prototype.uniformLocation = function(name) {\n      return this.shader.uniformLocation(name);\n    };\n\n    ShaderProxy.prototype.use = function() {\n      this.shader.use();\n      return this;\n    };\n\n    ShaderProxy.prototype.mat4 = function(name, value) {\n      this.shader.mat4(name, value);\n      return this;\n    };\n\n    ShaderProxy.prototype.vec2 = function(name, a, b) {\n      this.shader.vec2(name, a, b);\n      return this;\n    };\n\n    ShaderProxy.prototype.vec3 = function(name, a, b, c) {\n      this.shader.vec3(name, a, b, c);\n      return this;\n    };\n\n    ShaderProxy.prototype.vec4 = function(name, a, b, c, d) {\n      this.shader.vec4(name, a, b, c, d);\n      return this;\n    };\n\n    ShaderProxy.prototype.int = function(name, value) {\n      this.shader.int(name, value);\n      return this;\n    };\n\n    ShaderProxy.prototype.uniformSetter = function(obj) {\n      this.shader.uniformSetter(obj);\n      return this;\n    };\n\n    ShaderProxy.prototype.float = function(name, value) {\n      this.shader.float(name, value);\n      return this;\n    };\n\n    return ShaderProxy;\n\n  })(ShaderObj);\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/shims.coffee":{"modified":1418481143821,"content":"sys.defModule('/webgl/shims', function(exports, require, fs) {\n  var getAttrib, getAttribName, startTime, vendorName, vendors, _ref;\n  vendors = [null, 'webkit', 'apple', 'moz', 'o', 'xv', 'ms', 'khtml', 'atsc', 'wap', 'prince', 'ah', 'hp', 'ro', 'rim', 'tc'];\n  vendorName = function(name, vendor) {\n    if (vendor === null) {\n      return name;\n    } else {\n      return vendor + name[0].toUpperCase() + name.substr(1);\n    }\n  };\n  getAttribName = function(obj, name) {\n    var attrib, attrib_name, vendor, _i, _len;\n    for (_i = 0, _len = vendors.length; _i < _len; _i++) {\n      vendor = vendors[_i];\n      attrib_name = vendorName(name, vendor);\n      attrib = obj[attrib_name];\n      if (attrib != null) {\n        return attrib_name;\n      }\n    }\n  };\n  getAttrib = function(obj, name, def) {\n    var attrib, attrib_name, vendor, _i, _len;\n    if (obj) {\n      for (_i = 0, _len = vendors.length; _i < _len; _i++) {\n        vendor = vendors[_i];\n        attrib_name = vendorName(name, vendor);\n        attrib = obj[attrib_name];\n        if (attrib != null) {\n          return attrib;\n        }\n      }\n    }\n    return def;\n  };\n  window.performance = getAttrib(window, 'performance');\n  if (window.performance == null) {\n    window.performance = {};\n  }\n  window.performance.now = getAttrib(window.performance, 'now');\n  if (window.performance.now == null) {\n    startTime = Date.now();\n    window.performance.now = function() {\n      return Date.now() - startTime;\n    };\n  }\n  window.requestAnimationFrame = getAttrib(window, 'requestAnimationFrame', function(callback) {\n    return setTimeout(callback, 1000 / 60);\n  });\n  window.fullscreen = {\n    enabled: (_ref = getAttrib(document, 'fullScreenEnabled')) != null ? _ref : getAttrib(document, 'fullscreenEnabled'),\n    element: function() {\n      var _ref1;\n      return (_ref1 = getAttrib(document, 'fullScreenElement')) != null ? _ref1 : getAttrib(document, 'fullscreenElement');\n    },\n    exit: function() {\n      var name, _ref1, _ref2, _ref3;\n      name = (_ref1 = (_ref2 = (_ref3 = getAttribName(document, 'exitFullScreen')) != null ? _ref3 : getAttribName(document, 'exitFullscreen')) != null ? _ref2 : getAttribName(document, 'cancelFullScreen')) != null ? _ref1 : getAttribName(document, 'cancelFullscreen');\n      if (name != null) {\n        return document[name]();\n      }\n    },\n    request: function(element) {\n      var name, _ref1;\n      name = (_ref1 = getAttribName(element, 'requestFullScreen')) != null ? _ref1 : getAttribName(element, 'requestFullscreen');\n      if (name != null) {\n        return element[name]();\n      }\n    },\n    addEventListener: function(callback) {\n      var onChange, vendor, _i, _len, _ref1;\n      onChange = function(event) {\n        event.entered = fullscreen.element() != null;\n        return callback(event);\n      };\n      document.addEventListener('fullscreenchange', onChange);\n      _ref1 = vendors.slice(1);\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        vendor = _ref1[_i];\n        document.addEventListener(vendor + 'fullscreenchange', onChange);\n      }\n    }\n  };\n  fullscreen.addEventListener(function(event) {\n    var element;\n    element = event.target;\n    if (event.entered) {\n      return element.className += ' fullscreen';\n    } else {\n      return element.className = element.className.replace(' fullscreen', '').replace('fullscreen', '');\n    }\n  });\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/state.coffee":{"modified":1438787404078,"content":"var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nsys.defModule('/webgl/state', function(exports, require, fs) {\n  var BaseBuffer, ShaderObj, State, VertexBuffer, framebuffer, util, _ref;\n  util = require('util');\n  _ref = require('vertexbuffer'), BaseBuffer = _ref.BaseBuffer, VertexBuffer = _ref.VertexBuffer;\n  ShaderObj = require('shader').ShaderObj;\n  framebuffer = require('framebuffer');\n  exports = State = (function() {\n    function State(gf, params) {\n      var uniform, _i, _len, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;\n      this.gf = gf;\n      this.blendMultiply = __bind(this.blendMultiply, this);\n      this.blendAdd = __bind(this.blendAdd, this);\n      this.blendAlpha = __bind(this.blendAlpha, this);\n      this.gl = this.gf.gl;\n      if (params.shader instanceof ShaderObj) {\n        this.shader = params.shader;\n        this.ownShader = false;\n      } else {\n        this.shader = this.gf.shader(params.shader);\n        this.ownShader = true;\n      }\n      if (params.framebuffer != null) {\n        if (params.framebuffer instanceof framebuffer.Framebuffer) {\n          this.framebuffer = params.framebuffer;\n          this.ownFramebuffer = false;\n        } else {\n          this.framebuffer = this.gf.framebuffer(params.framebuffer);\n          this.ownFramebuffer = true;\n        }\n      } else {\n        this.framebuffer = null;\n        this.ownFramebuffer = false;\n      }\n      if (params.vertexbuffer != null) {\n        this.vertexbuffer(params.vertexbuffer);\n      } else {\n        this.vertexbuffer(this.gf.quadVertices);\n      }\n      this.texturesByName = {};\n      this.textures = [];\n      this.depthTest = (_ref1 = params.depthTest) != null ? _ref1 : false;\n      this.depthWrite = (_ref2 = params.depthWrite) != null ? _ref2 : true;\n      if (params.colorMask != null) {\n        if (typeof params.colorMask === 'boolean') {\n          this.colorWrite = [params.colorMask, params.colorMask, params.colorMask, params.colorMask];\n        } else {\n          this.colorWrite = [(_ref3 = params.colorMask[0]) != null ? _ref3 : true, (_ref4 = params.colorMask[1]) != null ? _ref4 : true, (_ref5 = params.colorMask[2]) != null ? _ref5 : true, (_ref6 = params.colorMask[3]) != null ? _ref6 : true];\n        }\n      } else {\n        this.colorWrite = [true, true, true, true];\n      }\n      if (params.depthFunc != null) {\n        this.depthFunc = (_ref7 = this.gl[params.depthFunc.toUpperCase()]) != null ? _ref7 : this.gl.LESS;\n      } else {\n        this.depthFunc = this.gl.LESS;\n      }\n      if (params.cull != null) {\n        this.cullFace = (_ref8 = this.gl[params.cull.toUpperCase()]) != null ? _ref8 : this.gl.BACK;\n      } else {\n        this.cullFace = false;\n      }\n      this.lineWidth = (_ref9 = params.lineWidth) != null ? _ref9 : 1;\n      if (params.blend != null) {\n        switch (params.blend) {\n          case 'alpha':\n            this.blend = this.blendAlpha;\n            break;\n          case 'add':\n            this.blend = this.blendAdd;\n            break;\n          case 'multiply':\n            this.blend = this.blendMultiply;\n            break;\n          default:\n            throw new Error('blend mode is not implemented: ' + params.blend);\n        }\n      } else {\n        this.blend = null;\n      }\n      if (params.uniforms != null) {\n        _ref10 = params.uniforms;\n        for (_i = 0, _len = _ref10.length; _i < _len; _i++) {\n          uniform = _ref10[_i];\n          this[uniform.type](uniform.name, uniform.value);\n        }\n      }\n      if (this.gf.vao != null) {\n        this.vao = this.gf.vao.createVertexArrayOES();\n        this.gf.vao.bindVertexArrayOES(this.vao);\n        this.setPointers();\n        this.gf.vao.bindVertexArrayOES(null);\n      } else {\n        this.vao = null;\n      }\n    }\n\n    State.prototype.vertexbuffer = function(buffer) {\n      var location, pointer, _i, _len, _ref1, _results;\n      if (buffer instanceof BaseBuffer) {\n        this.vbo = buffer;\n        this.ownvbo = false;\n      } else {\n        this.vbo = this.gf.vertexbuffer(buffer);\n        this.ownvbo = true;\n      }\n      this.pointers = (function() {\n        var _i, _ref1, _results;\n        _results = [];\n        for (location = _i = 0, _ref1 = this.gf.maxAttribs; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; location = 0 <= _ref1 ? ++_i : --_i) {\n          _results.push(null);\n        }\n        return _results;\n      }).call(this);\n\n      /*\n      location = 0\n      for pointer in @vbo.pointers\n          @shader.attributeLocation(pointer.name)?\n              pointer = util.clone pointer\n              pointer.location = location\n              @shader.attributeLocation(pointer.name, location)\n              @pointers[location] = pointer\n              location += 1\n       */\n      _ref1 = this.vbo.getPointers();\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        pointer = _ref1[_i];\n        location = this.shader.attributeLocation(pointer.name);\n        if (location != null) {\n          pointer = util.clone(pointer);\n          pointer.location = location;\n          this.shader.attributeLocation(pointer.name, location);\n          _results.push(this.pointers[location] = pointer);\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    State.prototype.destroy = function() {\n      if (this.ownShader) {\n        this.shader.destroy();\n      }\n      if (this.ownvbo) {\n        this.vbo.destroy();\n      }\n      if (this.vao != null) {\n        return this.gf.vao.deleteVertexArrayOES(this.vao);\n      }\n    };\n\n    State.prototype.blendAlpha = function() {\n      this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n      return this.gl.enable(this.gl.BLEND);\n    };\n\n    State.prototype.blendAdd = function() {\n      this.gl.blendFunc(this.gl.ONE, this.gl.ONE);\n      return this.gl.enable(this.gl.BLEND);\n    };\n\n    State.prototype.blendMultiply = function() {\n      this.gl.blendFunc(this.gl.DST_COLOR, this.gl.ZERO);\n      return this.gl.enable(this.gl.BLEND);\n    };\n\n    State.prototype.clearColor = function(r, g, b, a) {\n      if (r == null) {\n        r = 0;\n      }\n      if (g == null) {\n        g = 0;\n      }\n      if (b == null) {\n        b = 0;\n      }\n      if (a == null) {\n        a = 1;\n      }\n      this.setSurface();\n      this.gl.colorMask(true, true, true, true);\n      this.gl.clearColor(r, g, b, a);\n      this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n      return this;\n    };\n\n    State.prototype.clearDepth = function(value) {\n      if (value == null) {\n        value = 1;\n      }\n      this.setSurface();\n      this.gl.depthMask(true);\n      this.gl.clearDepth(value);\n      this.gl.clear(this.gl.DEPTH_BUFFER_BIT);\n      return this;\n    };\n\n    State.prototype.setViewport = function(width, height) {\n      if (width == null) {\n        width = this.gl.canvas.width;\n      }\n      if (height == null) {\n        height = this.gl.canvas.height;\n      }\n      return this.gl.viewport(0, 0, width, height);\n    };\n\n    State.prototype.setPointers = function() {\n      var location, pointer, _i, _len, _ref1;\n      this.vbo.bind();\n      _ref1 = this.pointers;\n      for (location = _i = 0, _len = _ref1.length; _i < _len; location = ++_i) {\n        pointer = _ref1[location];\n        if (pointer != null) {\n          if (!this.gf.vertexUnits[location].enabled) {\n            this.gf.vertexUnits[location].enabled = true;\n            this.gl.enableVertexAttribArray(pointer.location);\n          }\n          this.gl.vertexAttribPointer(pointer.location, pointer.size, pointer.type, true, pointer.stride, pointer.offset);\n        } else {\n          if (this.gf.vertexUnits[location].enabled) {\n            this.gf.vertexUnits[location].enabled = false;\n            this.gl.disableVertexAttribArray(location);\n          }\n        }\n      }\n    };\n\n    State.prototype.setupVertexBuffer = function() {\n      if (this.vao != null) {\n        return this.gf.vao.bindVertexArrayOES(this.vao);\n      } else {\n        return this.setPointers();\n      }\n    };\n\n    State.prototype.colorMask = function(r, g, b, a) {\n      if (r == null) {\n        r = true;\n      }\n      if (g == null) {\n        g = true;\n      }\n      if (b == null) {\n        b = true;\n      }\n      if (a == null) {\n        a = true;\n      }\n      this.gl.colorMask(r, g, b, a);\n      this.colorWrite[0] = r;\n      this.colorWrite[1] = g;\n      this.colorWrite[2] = b;\n      this.colorWrite[3] = a;\n      return this;\n    };\n\n    State.prototype.setupState = function() {\n      this.setSurface();\n      if (this.depthTest) {\n        this.gl.enable(this.gl.DEPTH_TEST);\n        this.gl.depthFunc(this.depthFunc);\n      } else {\n        this.gl.disable(this.gl.DEPTH_TEST);\n      }\n      this.gl.depthMask(this.depthWrite);\n      this.gl.colorMask(this.colorWrite[0], this.colorWrite[1], this.colorWrite[2], this.colorWrite[3]);\n      if (this.cullFace) {\n        this.gl.enable(this.gl.CULL_FACE);\n        this.gl.cullFace(this.cullFace);\n      } else {\n        this.gl.disable(this.gl.CULL_FACE);\n      }\n      if (this.blend != null) {\n        this.blend();\n      } else {\n        this.gl.disable(this.gl.BLEND);\n      }\n      if (this.vbo.getMode() === this.gl.LINES || this.vbo.getMode() === this.gl.LINE_STRIP) {\n        if (this.gf.lineWidth !== this.lineWidth) {\n          this.gf.lineWidth = this.lineWidth;\n          this.gl.lineWidth(this.lineWidth);\n        }\n      }\n      this.shader.use();\n      this.setupVertexBuffer();\n      return this.gf.currentState = this;\n    };\n\n    State.prototype.viewport = function(x, y, width, height) {\n      if (this.viewportParams != null) {\n        this.viewportParams.x = x;\n        this.viewportParams.y = y;\n        this.viewportParams.width = width;\n        this.viewportParams.height = height;\n      } else {\n        this.viewportParams = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n      }\n      this.gl.viewport(x, y, width, height);\n      return this;\n    };\n\n    State.prototype.setSurface = function() {\n      if (this.framebuffer != null) {\n        if (this.viewportParams != null) {\n          this.gl.viewport(this.viewportParams.x, this.viewportParams.y, this.viewportParams.width, this.viewportParams.height);\n        } else {\n          this.framebuffer.viewport();\n        }\n        return this.framebuffer.use();\n      } else {\n        this.setViewport();\n        if (this.gf.currentFramebuffer != null) {\n          return this.gf.currentFramebuffer.unuse();\n        }\n      }\n    };\n\n    State.prototype.draw = function(first, count, mode) {\n      var texture, unit, _i, _len, _ref1;\n      _ref1 = this.textures;\n      for (unit = _i = 0, _len = _ref1.length; _i < _len; unit = ++_i) {\n        texture = _ref1[unit];\n        texture.texture.bind(unit);\n        this.int(texture.name, unit);\n      }\n      if (this.gf.currentState !== this) {\n        this.setupState();\n      }\n      this.vbo.draw(first, count, mode);\n      return this;\n    };\n\n    State.prototype.mat4 = function(name, value) {\n      this.shader.mat4(name, value);\n      return this;\n    };\n\n    State.prototype.mat3 = function(name, value) {\n      this.shader.mat3(name, value);\n      return this;\n    };\n\n    State.prototype.int = function(name, value) {\n      this.shader.int(name, value);\n      return this;\n    };\n\n    State.prototype.vec2 = function(name, a, b) {\n      this.shader.vec2(name, a, b);\n      return this;\n    };\n\n    State.prototype.vec3 = function(name, a, b, c) {\n      this.shader.vec3(name, a, b, c);\n      return this;\n    };\n\n    State.prototype.vec4 = function(name, a, b, c, d) {\n      this.shader.vec4(name, a, b, c, d);\n      return this;\n    };\n\n    State.prototype.uniformSetter = function(obj) {\n      obj.setUniformsOn(this);\n      return this;\n    };\n\n    State.prototype.float = function(name, value) {\n      this.shader.float(name, value);\n      return this;\n    };\n\n    State.prototype.sampler = function(name, texture) {\n      var stored;\n      stored = this.texturesByName[name];\n      if (stored == null) {\n        stored = {\n          name: name,\n          texture: texture\n        };\n        this.texturesByName[name] = stored;\n        this.textures.push(stored);\n      }\n      if (stored.texture !== texture) {\n        stored.texture = texture;\n      }\n      return this;\n    };\n\n    State.prototype.bind = function(unit) {\n      if (unit == null) {\n        unit = 0;\n      }\n      if (this.framebuffer != null) {\n        this.framebuffer.bind(unit);\n      } else {\n        throw new Error('State has no attached framebuffer');\n      }\n      return this;\n    };\n\n    State.prototype.generateMipmap = function() {\n      if (this.framebuffer != null) {\n        this.framebuffer.generateMipmap();\n      } else {\n        throw new Error('State has no attached framebuffer');\n      }\n      return this;\n    };\n\n    State.prototype.anisotropy = function() {\n      if (this.framebuffer != null) {\n        this.framebuffer.anisotropy();\n      } else {\n        throw new Error('State has no attached framebuffer');\n      }\n      return this;\n    };\n\n    State.prototype.vertices = function(data) {\n      this.vbo.vertices(data);\n      return this;\n    };\n\n    State.prototype.cubeSide = function(name) {\n      if (this.framebuffer != null) {\n        this.framebuffer.cubeSide(name);\n      } else {\n        throw new Error('State has no attached framebuffer');\n      }\n      return this;\n    };\n\n    State.prototype.sizeEqual = function(width, height) {\n      if (this.framebuffer != null) {\n        return this.framebuffer.sizeEqual(width, height);\n      } else {\n        throw new Error('State has no attached framebuffer');\n      }\n    };\n\n    State.prototype.setSize = function(width, height) {\n      if (this.framebuffer != null) {\n        return this.framebuffer.setSize(width, height);\n      } else {\n        throw new Error('State has no attached framebuffer');\n      }\n    };\n\n    State.prototype.width = function() {\n      if (this.framebuffer != null) {\n        return this.framebuffer.width();\n      } else {\n        throw new Error('State has no attached framebuffer');\n      }\n    };\n\n    State.prototype.height = function() {\n      if (this.framebuffer != null) {\n        return this.framebuffer.height();\n      } else {\n        throw new Error('State has no attached framebuffer');\n      }\n    };\n\n    State.prototype.blit = function() {\n      return this.framebuffer.blit();\n    };\n\n    State.prototype.readPixels = function(x, y, width, height) {\n      if (this.framebuffer != null) {\n        return this.framebuffer.readPixels(x, y, width, height);\n      } else {\n        throw new Error('State has no attached framebuffer');\n      }\n    };\n\n    return State;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/texture-float.coffee":{"modified":1418811293221,"content":"sys.defModule('/webgl/texture-float', function(exports, require, fs) {\n  var draw, renderable;\n  draw = function(gl, _arg) {\n    var buffer, fragment, fragmentShader, positionLoc, program, sourceLoc, vertex, vertexShader, vertices;\n    vertex = _arg.vertex, fragment = _arg.fragment;\n    gl.activeTexture(gl.TEXTURE0);\n    program = gl.createProgram();\n    vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.attachShader(program, vertexShader);\n    gl.shaderSource(vertexShader, vertex);\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      throw gl.getShaderInfoLog(vertexShader);\n    }\n    fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.attachShader(program, fragmentShader);\n    gl.shaderSource(fragmentShader, fragment);\n    gl.compileShader(fragmentShader);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      throw gl.getShaderInfoLog(fragmentShader);\n    }\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      throw gl.getProgramInfoLog(program);\n    }\n    gl.useProgram(program);\n    vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);\n    buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n    positionLoc = gl.getAttribLocation(program, 'position');\n    gl.enableVertexAttribArray(positionLoc);\n    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\n    sourceLoc = gl.getUniformLocation(program, 'source');\n    if (sourceLoc != null) {\n      gl.uniform1i(sourceLoc, 0);\n    }\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    gl.deleteProgram(program);\n    return gl.deleteBuffer(buffer);\n  };\n  renderable = function(gl, targetType, channels) {\n    var check, pixels, readbackFramebuffer, readbackTexture, sourceFramebuffer, sourceTexture;\n    sourceTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, sourceTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, channels, 2, 2, 0, channels, targetType, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    sourceFramebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, sourceFramebuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, sourceTexture, 0);\n    check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (check !== gl.FRAMEBUFFER_COMPLETE) {\n      gl.deleteTexture(sourceTexture);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      return false;\n    }\n    draw(gl, {\n      vertex: 'attribute vec2 position;\\nvoid main(){\\n    gl_Position = vec4(position, 0, 1);\\n}',\n      fragment: 'void main(){\\n    gl_FragColor = vec4(0.5);\\n}'\n    });\n    gl.deleteFramebuffer(sourceFramebuffer);\n    readbackTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, readbackTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    readbackFramebuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, readbackFramebuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, readbackTexture, 0);\n    gl.bindTexture(gl.TEXTURE_2D, sourceTexture);\n    draw(gl, {\n      vertex: 'varying vec2 texcoord;\\nattribute vec2 position;\\nvoid main(){\\n    texcoord = position*0.5+0.5;\\n    gl_Position = vec4(position, 0, 1);\\n}',\n      fragment: 'precision highp int;\\nprecision highp float;\\nvarying vec2 texcoord;\\nuniform sampler2D source;\\nvoid main(){\\n    gl_FragColor = texture2D(source, texcoord);\\n}'\n    });\n    pixels = new Uint8Array(2 * 2 * 4);\n    gl.readPixels(0, 0, 2, 2, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    gl.deleteTexture(sourceTexture);\n    gl.deleteTexture(readbackTexture);\n    gl.deleteFramebuffer(readbackFramebuffer);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    console.assert(gl.getError() === gl.NO_ERROR);\n    return pixels[0] >= 126 && pixels[0] <= 128;\n  };\n  exports = function(gl) {\n    var float16, float16linear, float32, float32linear, result;\n    float16 = gl.getExtension('OES_texture_half_float');\n    float16linear = gl.getExtension('OES_texture_half_float_linear');\n    float32 = gl.getExtension('OES_texture_float');\n    float32linear = gl.getExtension('OES_texture_float_linear');\n    result = {};\n    if (float16 != null) {\n      result.float16 = {\n        linear: float16linear != null,\n        type: float16.HALF_FLOAT_OES,\n        renderable: renderable(gl, float16.HALF_FLOAT_OES, gl.RGBA)\n      };\n    }\n    if (float32 != null) {\n      result.float32 = {\n        linear: float32linear != null,\n        type: gl.FLOAT,\n        renderable: renderable(gl, gl.FLOAT, gl.RGBA)\n      };\n    }\n    return result;\n  };\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/texture.coffee":{"modified":1438933487674,"content":"var __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nsys.defModule('/webgl/texture', function(exports, require, fs) {\n  var ConcreteTexture, CubeSide, Texture, Texture2D, TextureCube;\n  exports.Texture = Texture = (function() {\n    function Texture() {}\n\n    return Texture;\n\n  })();\n  ConcreteTexture = (function(_super) {\n    __extends(ConcreteTexture, _super);\n\n    function ConcreteTexture(gf, params) {\n      var clamp, filter, sClamp, tClamp, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;\n      this.gf = gf;\n      if (params == null) {\n        params = {};\n      }\n      this.gl = this.gf.gl;\n      this.handle = this.gl.createTexture();\n      this.channels = this.gl[((_ref = params.channels) != null ? _ref : 'rgba').toUpperCase()];\n      this.bind();\n      if (typeof params.type === 'string') {\n        this.type = this.gl[((_ref1 = params.type) != null ? _ref1 : 'unsigned_byte').toUpperCase()];\n      } else {\n        this.type = (_ref2 = params.type) != null ? _ref2 : this.gl.UNSIGNED_BYTE;\n      }\n      filter = (_ref3 = params.filter) != null ? _ref3 : 'nearest';\n      if (typeof filter === 'string') {\n        this[filter]();\n      } else {\n        this.minify = (_ref4 = this.gl[filter.minify.toUpperCase()]) != null ? _ref4 : this.gl.LINEAR;\n        this.magnify = (_ref5 = this.gl[filter.magnify.toUpperCase()]) != null ? _ref5 : this.gl.LINEAR;\n        this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magnify);\n        this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minify);\n      }\n      clamp = (_ref6 = params.clamp) != null ? _ref6 : 'edge';\n      if (typeof clamp === 'string') {\n        this[clamp]();\n      } else {\n        if (clamp.s === 'edge') {\n          sClamp = this.gl.CLAMP_TO_EDGE;\n        } else if (clamp.s === 'repeat') {\n          sClamp = this.gl.REPEAT;\n        } else {\n          throw new Error('unknown S clamp mode: ' + clamp.s);\n        }\n        if (clamp.t === 'edge') {\n          tClamp = this.gl.CLAMP_TO_EDGE;\n        } else if (clamp.t === 'repeat') {\n          tClamp = this.gl.REPEAT;\n        } else {\n          throw new Error('unknown T clamp mode: ' + clamp.t);\n        }\n        this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, sClamp);\n        this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, tClamp);\n      }\n    }\n\n    ConcreteTexture.prototype.destroy = function() {\n      return this.gl.deleteTexture(this.handle);\n    };\n\n    ConcreteTexture.prototype.generateMipmap = function() {\n      this.mipmapped = true;\n      this.bind();\n      this.gl.generateMipmap(this.target);\n      return this;\n    };\n\n    ConcreteTexture.prototype.anisotropy = function() {\n      var ext, max;\n      this.anisotropic = true;\n      ext = this.gl.getExtension('EXT_texture_filter_anisotropic');\n      if (ext) {\n        max = this.gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n        this.gl.texParameterf(this.target, ext.TEXTURE_MAX_ANISOTROPY_EXT, max);\n      }\n      return this;\n    };\n\n    ConcreteTexture.prototype.linear = function() {\n      this.bind();\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n      return this;\n    };\n\n    ConcreteTexture.prototype.nearest = function() {\n      this.bind();\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\n      return this;\n    };\n\n    ConcreteTexture.prototype.repeat = function() {\n      this.bind();\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);\n      return this;\n    };\n\n    ConcreteTexture.prototype.edge = function() {\n      this.bind();\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n      return this;\n    };\n\n    ConcreteTexture.prototype.bind = function(unit) {\n      if (unit == null) {\n        unit = 0;\n      }\n\n      /*\n      if @gf.textureUnits[unit] isnt @\n          @gf.textureUnits[unit] = @\n          @gl.activeTexture @gl.TEXTURE0+unit\n          @gl.bindTexture @target, @handle\n       */\n      this.gl.activeTexture(this.gl.TEXTURE0 + unit);\n      this.gl.bindTexture(this.target, this.handle);\n      return this;\n    };\n\n    return ConcreteTexture;\n\n  })(exports.Texture);\n  CubeSide = (function(_super) {\n    __extends(CubeSide, _super);\n\n    function CubeSide(handle, target) {\n      this.handle = handle;\n      this.target = target;\n    }\n\n    return CubeSide;\n\n  })(exports.Texture);\n  exports.TextureCube = TextureCube = (function(_super) {\n    __extends(TextureCube, _super);\n\n    function TextureCube(gf, params) {\n      var _ref;\n      this.gf = gf;\n      if (params == null) {\n        params = {};\n      }\n      this.target = this.gf.gl.TEXTURE_CUBE_MAP;\n      TextureCube.__super__.constructor.call(this, this.gf, params);\n      this.negativeX = new CubeSide(this.handle, this.gl.TEXTURE_CUBE_MAP_NEGATIVE_X);\n      this.negativeY = new CubeSide(this.handle, this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y);\n      this.negativeZ = new CubeSide(this.handle, this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z);\n      this.positiveX = new CubeSide(this.handle, this.gl.TEXTURE_CUBE_MAP_POSITIVE_X);\n      this.positiveY = new CubeSide(this.handle, this.gl.TEXTURE_CUBE_MAP_POSITIVE_Y);\n      this.positiveZ = new CubeSide(this.handle, this.gl.TEXTURE_CUBE_MAP_POSITIVE_Z);\n      this.size(params.size);\n      if ((_ref = this.minify) === this.gl.NEAREST_MIPMAP_NEAREST || _ref === this.gl.LINEAR_MIPMAP_NEAREST || _ref === this.gl.NEAREST_MIPMAP_LINEAR || _ref === this.gl.LINEAR_MIPMAP_LINEAR) {\n        this.generateMipmap();\n      }\n    }\n\n    TextureCube.prototype.size = function(size) {\n      this.size = size;\n      this.bind();\n      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, this.channels, this.size, this.size, 0, this.channels, this.type, null);\n      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, this.channels, this.size, this.size, 0, this.channels, this.type, null);\n      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, this.channels, this.size, this.size, 0, this.channels, this.type, null);\n      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, this.channels, this.size, this.size, 0, this.channels, this.type, null);\n      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, this.channels, this.size, this.size, 0, this.channels, this.type, null);\n      this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, this.channels, this.size, this.size, 0, this.channels, this.type, null);\n      return this;\n    };\n\n    TextureCube.prototype.dataSized = function(data, side, size) {\n      this.size = size;\n      this.bind();\n      this.gl.texImage2D(this[side].target, 0, this.channels, this.size, this.size, 0, this.channels, this.type, data);\n      return this;\n    };\n\n    return TextureCube;\n\n  })(ConcreteTexture);\n  exports.Texture2D = Texture2D = (function(_super) {\n    __extends(Texture2D, _super);\n\n    function Texture2D(gf, params) {\n      var _ref;\n      this.gf = gf;\n      if (params == null) {\n        params = {};\n      }\n      this.target = this.gf.gl.TEXTURE_2D;\n      Texture2D.__super__.constructor.call(this, this.gf, params);\n      if (params.data instanceof Image) {\n        this.dataImage(params.data);\n      } else if ((params.width != null) && (params.height != null)) {\n        if (params.data != null) {\n          this.dataSized(params.data, params.width, params.height);\n        } else {\n          this.size(params.width, params.height);\n        }\n      }\n      if ((_ref = this.minify) === this.gl.NEAREST_MIPMAP_NEAREST || _ref === this.gl.LINEAR_MIPMAP_NEAREST || _ref === this.gl.NEAREST_MIPMAP_LINEAR || _ref === this.gl.LINEAR_MIPMAP_LINEAR) {\n        if (params.data != null) {\n          this.generateMipmap();\n        }\n      }\n    }\n\n    Texture2D.prototype.loadImage = function(url, flipped) {\n      var image;\n      if (flipped == null) {\n        flipped = false;\n      }\n      image = new Image();\n      image.onload = (function(_this) {\n        return function() {\n          return _this.dataImage(image, flipped);\n        };\n      })(this);\n      image.src = url;\n      return this;\n    };\n\n    Texture2D.prototype.dataImage = function(data, flipped) {\n      if (flipped == null) {\n        flipped = false;\n      }\n      this.bind();\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, flipped);\n      this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n      this.gl.pixelStorei(this.gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this.gl.NONE);\n      this.width = data.width;\n      this.height = data.height;\n      this.gl.texImage2D(this.target, 0, this.channels, this.channels, this.type, data);\n      return this;\n    };\n\n    Texture2D.prototype.dataSized = function(data, width, height, flipped) {\n      if (flipped == null) {\n        flipped = false;\n      }\n      if (data instanceof Array) {\n        data = new Uint8Array(data);\n      }\n      this.bind(10);\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, flipped);\n      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);\n      this.width = width;\n      this.height = height;\n      this.gl.texImage2D(this.target, 0, this.channels, this.width, this.height, 0, this.channels, this.type, data);\n      return this;\n    };\n\n    Texture2D.prototype.size = function(width, height) {\n      this.width = width;\n      this.height = height;\n      this.bind();\n      this.gl.texImage2D(this.target, 0, this.channels, this.width, this.height, 0, this.channels, this.type, null);\n      return this;\n    };\n\n    Texture2D.prototype.draw = function(scale) {\n      if (scale == null) {\n        scale = 1;\n      }\n      return this.gf.blit.float('scale', scale).sampler('source', this).draw();\n    };\n\n    Texture2D.prototype.blit = function() {\n      return this.draw();\n    };\n\n    Texture2D.prototype.read = function() {\n      this.gf.readFBO.color(this);\n      return console.log('here', this.width, this.height);\n    };\n\n    return Texture2D;\n\n  })(ConcreteTexture);\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/util.coffee":{"modified":1417176415221,"content":"sys.defModule('/webgl/util', function(exports, require, fs) {\n  exports.clone = function(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  };\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/vector.coffee":{"modified":1430114697684,"content":"sys.defModule('/webgl/vector', function(exports, require, fs) {\n  var Vec3, Vec4, tau;\n  tau = Math.PI * 2;\n  exports.Vec3 = Vec3 = (function() {\n    function Vec3(x, y, z) {\n      this.x = x != null ? x : 0;\n      this.y = y != null ? y : 0;\n      this.z = z != null ? z : 0;\n      null;\n    }\n\n    Vec3.prototype.set = function(x, y, z) {\n      this.x = x != null ? x : 0;\n      this.y = y != null ? y : 0;\n      this.z = z != null ? z : 0;\n      return this;\n    };\n\n    Vec3.prototype.set = function(x, y, z) {\n      var other;\n      if (x == null) {\n        x = 0;\n      }\n      if (y == null) {\n        y = 0;\n      }\n      if (z == null) {\n        z = 0;\n      }\n      if (typeof x === 'number') {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n      } else {\n        other = x;\n        this.x = other.x;\n        this.y = other.y;\n        this.z = other.z;\n      }\n      return this;\n    };\n\n    Vec3.prototype.rotatey = function(angle) {\n      var c, rad, s, x, z;\n      rad = tau * (angle / 360);\n      s = Math.sin(rad);\n      c = Math.cos(rad);\n      x = this.z * s + this.x * c;\n      z = this.z * c - this.x * s;\n      this.x = x;\n      this.z = z;\n      return this;\n    };\n\n    Vec3.prototype.normalize = function() {\n      var l;\n      l = this.slength();\n      if (l > 0) {\n        l = Math.sqrt(l);\n        this.x /= l;\n        this.y /= l;\n        this.z /= l;\n      }\n      return this;\n    };\n\n    Vec3.prototype.multiply = function(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      this.w *= scalar;\n      return this;\n    };\n\n    Vec3.prototype.add = function(other) {\n      this.x += other.x;\n      this.y += other.y;\n      this.z += other.z;\n      return this;\n    };\n\n    return Vec3;\n\n  })();\n  exports.Vec4 = Vec4 = (function() {\n    function Vec4(x, y, z, w) {\n      this.x = x != null ? x : 0;\n      this.y = y != null ? y : 0;\n      this.z = z != null ? z : 0;\n      this.w = w != null ? w : 1;\n    }\n\n    Vec4.prototype.normalize = function() {\n      var l;\n      l = this.slength();\n      if (l > 0) {\n        l = Math.sqrt(l);\n        this.x /= l;\n        this.y /= l;\n        this.z /= l;\n      }\n      return this;\n    };\n\n    Vec4.prototype.slength = function() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    };\n\n    Vec4.prototype.multiply = function(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      this.w *= scalar;\n      return this;\n    };\n\n    Vec4.prototype.add = function(other) {\n      this.x += other.x;\n      this.y += other.y;\n      this.z += other.z;\n      this.w += other.w;\n      return this;\n    };\n\n    Vec4.prototype.set = function(other) {\n      this.x = other.x;\n      this.y = other.y;\n      this.z = other.z;\n      this.w = other.w;\n      return this;\n    };\n\n    return Vec4;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/webgl/vertexbuffer.coffee":{"modified":1435852676194,"content":"var __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nsys.defModule('/webgl/vertexbuffer', function(exports, require, fs) {\n  var BaseBuffer, VertexBuffer, util;\n  util = require('util');\n  exports.BaseBuffer = BaseBuffer = (function() {\n    function BaseBuffer() {}\n\n    BaseBuffer.prototype.destroy = function() {\n      throw new Error('base method');\n    };\n\n    BaseBuffer.prototype.bind = function() {\n      throw new Error('base method');\n    };\n\n    BaseBuffer.prototype.getMode = function() {\n      throw new Error('base method');\n    };\n\n    BaseBuffer.prototype.draw = function(first, count, mode) {\n      throw new Error('base method');\n    };\n\n    BaseBuffer.prototype.getPointers = function() {\n      throw new Error('base method');\n    };\n\n    return BaseBuffer;\n\n  })();\n  exports.VertexBuffer = VertexBuffer = (function(_super) {\n    __extends(VertexBuffer, _super);\n\n    function VertexBuffer(gf, _arg) {\n      var mode, pointers, size, vertices, _ref;\n      this.gf = gf;\n      _ref = _arg != null ? _arg : {}, pointers = _ref.pointers, vertices = _ref.vertices, mode = _ref.mode, size = _ref.size, this.interleaved = _ref.interleaved;\n      if (this.interleaved == null) {\n        this.interleaved = true;\n      }\n      this.gl = this.gf.gl;\n      this.buffer = this.gl.createBuffer();\n      if (mode != null) {\n        this.mode = this.gl[mode.toUpperCase()];\n      } else {\n        this.mode = this.gl.TRIANGLES;\n      }\n      if (pointers != null) {\n        this.pointers(pointers);\n      }\n      if (vertices != null) {\n        this.vertices(vertices);\n      } else if (size != null) {\n        this.size(size);\n      }\n    }\n\n    VertexBuffer.prototype.getMode = function() {\n      return this.mode;\n    };\n\n    VertexBuffer.prototype.getPointers = function() {\n      return this.pointers;\n    };\n\n    VertexBuffer.prototype.destroy = function() {\n      this.gl.deleteBuffer(this.buffer);\n      return this;\n    };\n\n    VertexBuffer.prototype.update = function(params) {\n      if (params.pointers != null) {\n        this.pointers(params.pointers);\n      }\n      if (params.vertices != null) {\n        this.vertices(params.vertices);\n      }\n      return this;\n    };\n\n    VertexBuffer.prototype.pointers = function(data) {\n      var offset, pointer, _i, _len, _ref;\n      offset = 0;\n      this.pointers = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = data.length; _i < _len; _i++) {\n          pointer = data[_i];\n          pointer = util.clone(pointer);\n          if (pointer.size == null) {\n            pointer.size = 4;\n          }\n          if (pointer.type == null) {\n            pointer.type = 'float';\n          }\n          switch (pointer.type) {\n            case 'float':\n              pointer.type = this.gl.FLOAT;\n              pointer.typeSize = 4;\n              break;\n            case 'byte':\n              pointer.type = this.gl.BYTE;\n              pointer.typeSize = 1;\n              break;\n            case 'short':\n              pointer.type = this.gl.SHORT;\n              pointer.typeSize = 2;\n              break;\n            case 'ubyte':\n              pointer.type = this.gl.UNSIGNED_BYTE;\n              pointer.typeSize = 1;\n              break;\n            case 'ushort':\n              pointer.type = this.gl.UNSIGNED_SHORT;\n              pointer.typeSize = 2;\n              break;\n            default:\n              throw new Error('unknown pointer type: ' + pointer.type);\n          }\n          pointer.byteSize = pointer.typeSize * pointer.size;\n          if (pointer.offset == null) {\n            pointer.offset = offset;\n          }\n          offset += pointer.byteSize;\n          _results.push(pointer);\n        }\n        return _results;\n      }).call(this);\n      if (this.interleaved) {\n        _ref = this.pointers;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          pointer = _ref[_i];\n          if (pointer.stride == null) {\n            pointer.stride = offset;\n          }\n        }\n        this.stride = offset;\n      } else {\n        this.stride = null;\n      }\n      return this;\n    };\n\n    VertexBuffer.prototype.vertices = function(data) {\n      if (data instanceof Array) {\n        data = new Float32Array(data);\n      }\n      if (this.interleaved) {\n        this.count = data.byteLength / this.stride;\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, data, this.gl.STATIC_DRAW);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      } else {\n        this.count = data.count;\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, data.data, this.gl.STATIC_DRAW);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      }\n      return this;\n    };\n\n    VertexBuffer.prototype.size = function(size) {\n      this.count = size / this.stride;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, size, this.gl.STATIC_DRAW);\n      return this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    };\n\n    VertexBuffer.prototype.subData = function(offset, data) {\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\n      this.gl.bufferSubData(this.gl.ARRAY_BUFFER, offset, data);\n      return this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    };\n\n    VertexBuffer.prototype.bind = function() {\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\n      return this;\n    };\n\n    VertexBuffer.prototype.unbind = function() {\n      this.gf.currentVertexbuffer = null;\n      return this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    };\n\n    VertexBuffer.prototype.draw = function(first, count, mode) {\n      if (first == null) {\n        first = 0;\n      }\n      if (count == null) {\n        count = this.count;\n      }\n      if (mode == null) {\n        mode = this.mode;\n      }\n      this.gl.drawArrays(mode, first, count);\n      return this;\n    };\n\n    return VertexBuffer;\n\n  })(BaseBuffer);\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/test.coffee":{"modified":1438611069214,"content":"sys.defModule('/test', function(exports, require, fs) {\n  $(function() {\n    var PI, PIH, S2, TAU, abs, acos, asin, atan2, avgDist, canvas, clamp, cos, ctx, distance, dot, drawError, drawGrid, drawMeridians, drawNormals, gradient, linstep, map, mapRect, mapSphere, mix, mix2, normalize, pow, sh, sign, sin, size, sqrt, step, unmap, unmapRect, unmapSphere;\n    canvas = $('<canvas></canvas>').appendTo('body')[0];\n    size = 800;\n    sh = size / 2;\n    canvas.width = size;\n    canvas.height = size;\n    ctx = canvas.getContext('2d');\n    drawGrid = function() {\n      ctx.strokeStyle = 'red';\n      ctx.lineWidth = 0.5;\n      ctx.beginPath();\n      ctx.moveTo(sh, 0);\n      ctx.lineTo(0, sh);\n      ctx.lineTo(sh, size);\n      ctx.lineTo(size, sh);\n      ctx.lineTo(sh, 0);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(0, sh + 0.5);\n      ctx.lineTo(size, sh + 0.5);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(sh + 0.5, 0);\n      ctx.lineTo(sh + 0.5, size);\n      return ctx.stroke();\n    };\n    abs = Math.abs;\n    sign = function(value) {\n      if (value < 0) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n    sqrt = Math.sqrt;\n    pow = Math.pow;\n    acos = Math.acos;\n    cos = Math.cos;\n    asin = Math.asin;\n    sin = Math.sin;\n    atan2 = Math.atan2;\n    PI = Math.PI;\n    PIH = PI / 2;\n    TAU = PI * 2;\n    S2 = 1.41421356237309514547;\n    clamp = function(value, low, high) {\n      if (value < low) {\n        return low;\n      } else if (value > high) {\n        return high;\n      } else {\n        return value;\n      }\n    };\n    linstep = function(edge0, edge1, value) {\n      return clamp((value - edge0) / (edge1 - edge0), 0, 1);\n    };\n    dot = function(s, t, r, g, b) {\n      var x, y;\n      x = s * size;\n      y = t * size;\n      ctx.fillStyle = \"rgba(\" + ((r * 255).toFixed(0)) + \",\" + ((g * 255).toFixed(0)) + \",\" + ((b * 255).toFixed(0)) + \",1)\";\n      ctx.beginPath();\n      ctx.arc(x, y, 0.5, 0, Math.PI * 2);\n      return ctx.fill();\n    };\n    step = function(edge, value) {\n      if (value < edge) {\n        return -1;\n      } else {\n        return 1;\n      }\n    };\n    mix = function(v0, v1, a) {\n      return v0 * (1 - a) + v1 * a;\n    };\n    mix2 = function(_arg, _arg1, a) {\n      var x0, x1, y0, y1;\n      x0 = _arg[0], y0 = _arg[1];\n      x1 = _arg1[0], y1 = _arg1[1];\n      return [mix(x0, x1, a), mix(y0, y1, a)];\n    };\n    mapRect = function(x, y, z) {\n      var l, sx, sz;\n      l = abs(x) + abs(y) + abs(z);\n      x /= l;\n      y /= l;\n      z /= l;\n      if (y > 0) {\n        return [x, z];\n      } else {\n        sx = sign(x);\n        sz = sign(z);\n        return [sx - sx * abs(z), sz - sz * abs(x)];\n      }\n    };\n    normalize = function(_arg) {\n      var l, x, y, z;\n      x = _arg[0], y = _arg[1], z = _arg[2];\n      l = sqrt(x * x + y * y + z * z);\n      return [x / l, y / l, z / l];\n    };\n    unmapRect = function(s, t) {\n      var l, sx, sz, x, y, z;\n      s = s * 2 - 1;\n      t = t * 2 - 1;\n      l = abs(s) + abs(t);\n      if (l < 1) {\n        x = s;\n        z = t;\n        y = 1 - l;\n      } else {\n        sx = sign(s);\n        sz = sign(t);\n        x = sx * abs(t - sz);\n        z = sz * abs(s - sx);\n        y = abs(x) + abs(z) - 1;\n      }\n      return normalize([x, y, z]);\n    };\n    mapSphere = function(x, y, z) {\n      var e, o, s, t;\n      o = acos(abs(z) / sqrt(x * x + z * z)) / PIH;\n      e = acos(abs(y)) / PIH;\n      s = sign(x) * o * e;\n      t = sign(z) * (1 - o) * e;\n      if (y > 0) {\n        return [s, t];\n      } else {\n        return [sign(x) - abs(t) * sign(x), sign(z) - abs(s) * sign(z)];\n      }\n    };\n    unmapSphere = function(s, t) {\n      var e, o, x, y, z;\n      s = s * 2 - 1;\n      t = t * 2 - 1;\n      if (abs(s) + abs(t) < 1) {\n        x = s;\n        z = t;\n      } else {\n        x = (1 - abs(t)) * sign(s);\n        z = (1 - abs(s)) * sign(t);\n      }\n      o = (abs(x) / (abs(x) + abs(z))) * PIH;\n      e = ((abs(s) + abs(t)) / 2.0) * PI;\n      x = sin(o) * sign(s) * sin(e);\n      y = cos(e);\n      z = cos(o) * sign(t) * sin(e);\n      return [x, y, z];\n    };\n    map = mapSphere;\n    unmap = unmapSphere;\n    drawMeridians = function() {\n      var e, o, s, t, x, y, z, _i, _j, _k, _ref, _results;\n      for (e = _i = 0; _i <= 180; e = _i += 0.25) {\n        e = (e / 180) * Math.PI;\n        y = Math.cos(e);\n        for (o = _j = 0; _j <= 360; o = _j += 10) {\n          o = (o / 360) * Math.PI * 2;\n          x = Math.sin(o) * Math.sin(e);\n          z = Math.cos(o) * Math.sin(e);\n          _ref = map(x, y, z), s = _ref[0], t = _ref[1];\n          dot(s * 0.5 + 0.5, t * 0.5 + 0.5, x * 0.5 + 0.5, y * 0.5 + 0.5, z * 0.5 + 0.5);\n        }\n      }\n      _results = [];\n      for (e = _k = 0; _k <= 180; e = _k += 10) {\n        e = (e / 180) * Math.PI;\n        y = Math.cos(e);\n        _results.push((function() {\n          var _l, _ref1, _results1;\n          _results1 = [];\n          for (o = _l = 0; _l <= 360; o = _l += 0.25) {\n            o = (o / 360) * Math.PI * 2;\n            x = Math.sin(o) * Math.sin(e);\n            z = Math.cos(o) * Math.sin(e);\n            _ref1 = map(x, y, z), s = _ref1[0], t = _ref1[1];\n            _results1.push(dot(s * 0.5 + 0.5, t * 0.5 + 0.5, x * 0.5 + 0.5, y * 0.5 + 0.5, z * 0.5 + 0.5));\n          }\n          return _results1;\n        })());\n      }\n      return _results;\n    };\n    drawNormals = function() {\n      var data, idx, imageData, s, t, x, xn, y, yn, zn, _i, _j, _ref;\n      imageData = ctx.getImageData(0, 0, size, size);\n      data = imageData.data;\n      for (y = _i = 0; 0 <= size ? _i < size : _i > size; y = 0 <= size ? ++_i : --_i) {\n        for (x = _j = 0; 0 <= size ? _j < size : _j > size; x = 0 <= size ? ++_j : --_j) {\n          idx = (x + y * size) * 4;\n          s = (x + 0.5) / size;\n          t = (y + 0.5) / size;\n          _ref = unmap(s, t), xn = _ref[0], yn = _ref[1], zn = _ref[2];\n          data[idx + 0] = (xn * 0.5 + 0.5) * 255;\n          data[idx + 1] = (yn * 0.5 + 0.5) * 255;\n          data[idx + 2] = (zn * 0.5 + 0.5) * 255;\n          data[idx + 3] = 255;\n        }\n      }\n      return ctx.putImageData(imageData, 0, 0);\n    };\n    distance = function(_arg, _arg1) {\n      var x, x0, x1, y, y0, y1, z, z0, z1;\n      x0 = _arg[0], y0 = _arg[1], z0 = _arg[2];\n      x1 = _arg1[0], y1 = _arg1[1], z1 = _arg1[2];\n      x = x1 - x0;\n      y = y1 - y0;\n      z = z1 - z0;\n      return sqrt(x * x + y * y + z * z);\n    };\n    gradient = function(value) {\n      value = clamp(value, 0, 1);\n      return [value, 0, 1 - value];\n    };\n    drawError = function() {\n      var avg, avgError, b, count, d0, d1, d2, d3, data, dist, error, g, idx, imageData, maxError, minError, n00, n01, n10, n11, r, s0, s1, t0, t1, x, y, _i, _j, _ref, _ref1, _ref2;\n      avg = avgDist();\n      imageData = ctx.getImageData(0, 0, size, size);\n      data = imageData.data;\n      avgError = 0;\n      count = 0;\n      for (y = _i = 0, _ref = size - 1; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {\n        for (x = _j = 0, _ref1 = size - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {\n          idx = (x + y * size) * 4;\n          s0 = (x + 0.5) / size;\n          t0 = (y + 0.5) / size;\n          s1 = (x + 1.5) / size;\n          t1 = (y + 1.5) / size;\n          n00 = unmap(s0, t0);\n          n10 = unmap(s1, t0);\n          n01 = unmap(s0, t1);\n          n11 = unmap(s1, t1);\n          d0 = distance(n00, n10);\n          d1 = distance(n00, n01);\n          d2 = distance(n01, n11);\n          d3 = distance(n10, n11);\n          dist = (d0 + d1 + d2 + d3) / 4;\n          error = (dist - avg) * 200;\n          avgError += abs(error);\n          if (typeof minError !== \"undefined\" && minError !== null) {\n            minError = Math.min(minError, abs(error));\n            maxError = Math.max(maxError, abs(error));\n          } else {\n            minError = abs(error);\n            maxError = abs(error);\n          }\n          count += 1;\n          _ref2 = gradient(error + 0.5), r = _ref2[0], g = _ref2[1], b = _ref2[2];\n          data[idx + 0] = r * 255;\n          data[idx + 1] = g * 255;\n          data[idx + 2] = b * 255;\n          data[idx + 3] = 255;\n        }\n      }\n      console.log(avgError / count, minError, maxError);\n      return ctx.putImageData(imageData, 0, 0);\n    };\n    avgDist = function() {\n      var count, dist, idx, n00, n01, n10, n11, s0, s1, t0, t1, x, y, _i, _j, _ref, _ref1;\n      dist = 0;\n      count = 0;\n      for (y = _i = 0, _ref = size - 1; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {\n        for (x = _j = 0, _ref1 = size - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {\n          idx = (x + y * size) * 4;\n          s0 = (x + 0.5) / size;\n          t0 = (y + 0.5) / size;\n          s1 = (x + 1.5) / size;\n          t1 = (y + 1.5) / size;\n          n00 = unmap(s0, t0);\n          n10 = unmap(s1, t0);\n          n01 = unmap(s0, t1);\n          n11 = unmap(s1, t1);\n          dist += distance(n00, n10);\n          dist += distance(n00, n01);\n          dist += distance(n01, n11);\n          dist += distance(n10, n11);\n          count += 4;\n        }\n      }\n      return dist / count;\n    };\n    drawNormals();\n    drawMeridians();\n    return drawError();\n  });\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/display.shader":{"modified":1461225434596,"content":"sys.defFile(\"/display.shader\", \"#file /display.shader\\nvarying vec2 vTexcoord;\\nvarying vec3 vNormal;\\nvarying vec3 vWorldPosition, vViewPosition;\\n\\nvertex:\\n    attribute vec3 position;\\n    attribute vec2 texcoord;\\n    attribute vec3 normal;\\n\\n    uniform mat4 proj, view;\\n    uniform vec2 offset;\\n\\n    void main(){\\n        vTexcoord = texcoord;\\n        vNormal = normal;\\n        vWorldPosition = vec3(offset.x, 0, offset.y) + position;\\n        vViewPosition = (view*vec4(vWorldPosition, 1)).xyz;\\n        gl_Position = proj * vec4(vViewPosition, 1);\\n    }\\n\\nfragment:\\n    uniform sampler2D textureRadiance;\\n    uniform vec2 radianceSize;\\n\\n    vec3 getRadianceMip(vec2 uv, float vOffset, float lod){\\n        float size = pow(2.0, lod);\\n        \\n        float hOffset = pow(2.0, lod)-1.0 + lod*2.0;\\n        vec2 texcoord = (vec2(hOffset, vOffset)+1.0+uv*size)/radianceSize;\\n        return texture2D(textureRadiance, texcoord).rgb;\\n    }\\n\\n    vec3 getRadianceSlice(vec2 uv, float slice, float angularChange){\\n        float size = max(128.0, pow(2.0, slice+4.0));\\n        float offset0 = 130.0*min(slice,4.0);\\n        float i2 = max(slice-4.0, 0.0);\\n        float offset1 = pow(2.0, i2+8.0) - 256.0 + 2.0*i2;\\n        float vOffset = offset0 + offset1;\\n\\n        float maxLod = log(size)/log(2.0);\\n\\n        float pixelsPerChange = size*0.7*angularChange; // approximately 1/sqrt(2)\\n        float lod = log(pixelsPerChange)/log(2.0);\\n        lod = clamp(maxLod-lod, 0.0, maxLod);\\n        //lod = maxLod;\\n\\n        return mix(\\n            getRadianceMip(uv, vOffset, floor(lod)),\\n            getRadianceMip(uv, vOffset, floor(lod)+1.0),\\n            fract(lod)\\n        );\\n    }\\n    \\n    float translateRoughness(float roughness){\\n        float minAngle = 360.0/512.0;\\n        float basis = 2.5198420997897464;\\n        float angle = mix(minAngle, 180.0, roughness);\\n        float factor = 1.0 - logN(180.0/angle, basis)/6.0;\\n        return clamp(factor, 0.0, 1.0);\\n    }\\n\\n    uniform float exposure;\\n    vec3 getRadiance(vec3 dir, float roughness){\\n        roughness = translateRoughness(roughness);\\n\\n        vec3 dd = fwidth(normalize(dir));\\n        //float ddl2 = pow(length(dd), 2.0);\\n        float ddl2 = dot(dd,dd);\\n        float angularChange = acos(sqrt(4.0 - ddl2)*0.5)/PI;\\n\\n        //float angularChange = acos(dot(normalize(dir+fwidth(dir)), dir))/PI; // creates artifacts\\n\\n        vec2 uv = normalToUv(dir);\\n\\n        float slice = (1.0-roughness)*6.0;\\n        float slice0 = floor(slice);\\n        float slice1 = slice0 + 1.0;\\n        float f = fract(slice);\\n        \\n        vec3 color0 = getRadianceSlice(uv, slice0, angularChange);\\n        vec3 color1 = getRadianceSlice(uv, slice1, angularChange);\\n\\n        return mix(color0, color1, f)*exposure;\\n        //return vec3(angularChange*10.0);\\n    }\\n    \\n    vec3 getDiffuse(vec3 normal){\\n        return getRadiance(normal, 1.0)*exposure;\\n    }\\n\\n\\n    uniform mat3 invRot;\\n    uniform sampler2D textureBaseColor;\\n    uniform sampler2D textureAO;\\n    uniform sampler2D textureCavity;\\n    uniform sampler2D textureShadow;\\n\\n    uniform float diffuseReflectance, specularReflectance, specularMix, emissivity;\\n\\n    uniform float roughness1, fresnel1, metallness1;\\n    uniform float roughness2, fresnel2, metallness2;\\n\\n    float getFresnel(vec3 N, vec3 V, float r){\\n        float c = dot(N, V);\\n        r = pow(r, 5.0);\\n        return r+(1.0-r)*pow(1.0-c, 5.0);\\n    }\\n\\n    void test(){\\n        vec3 N = normalize(vNormal);\\n        vec3 V = invRot * normalize(-vViewPosition);\\n        vec3 R = reflect(-V, N);\\n        vec3 incident = getRadiance(R, 0.0);\\n        float luminance = incident.r+incident.g+incident.b;\\n        if(luminance > 4.0){\\n            gl_FragColor = vec4(gamma(incident),1);\\n        }\\n        else{\\n            gl_FragColor = vec4(0,0,0,1);\\n        }\\n    }\\n\\n    void main(){\\n        //test();\\n        \\n        vec3 N = normalize(vNormal);\\n        vec3 V = invRot * normalize(-vViewPosition);\\n        vec3 R = reflect(-V, N);\\n        \\n        //vec3 baseColor = degamma(texture2D(textureBaseColor, vTexcoord).rgb);\\n        vec3 baseColor = degamma(vec3(1));\\n        vec3 ao = degamma(texture2D(textureAO, vTexcoord).rgb);\\n        vec3 cavity = degamma(texture2D(textureCavity, vTexcoord).rgb);\\n        vec3 shadow = degamma(texture2D(textureShadow, vTexcoord).rgb);\\n\\n        vec3 diffuseIncident = getDiffuse(N)*ao;\\n        vec3 specularIncident1 = getRadiance(R, roughness1);\\n        vec3 specularIncident2 = getRadiance(R, roughness2);\\n\\n        float f1 = getFresnel(N, V, fresnel1)*specularReflectance;\\n        float f2 = getFresnel(N, V, fresnel2)*specularReflectance;\\n\\n        float f = mix(f1, f2, specularMix);\\n\\n        vec3 diffuseExcident = diffuseIncident*baseColor*diffuseReflectance*(1.0-f);\\n        vec3 specularExcident1 = mix(specularIncident1, specularIncident1*baseColor, metallness1)*f1;\\n        vec3 specularExcident2 = mix(specularIncident2, specularIncident2*baseColor, metallness2)*f2;\\n        vec3 specularExcident = mix(specularExcident1, specularExcident2, specularMix);\\n\\n        vec3 excident = diffuseExcident+specularExcident+emissivity*baseColor;\\n\\n        gl_FragColor = vec4(gamma(excident),1);\\n        //gl_FragColor = vec4(gamma(getRadiance(N, 1.0)),1);\\n        //gl_FragColor = vec4(1,0,1,1);\\n    }\");"},"/root/www/codeflow/webgl/envmapper3/src/file-system.coffee":{"modified":1444849290674,"content":"sys.defModule('/file-system', function(exports, require, fs) {\n  var readImage, readText;\n  readImage = function(entry, file, onLoad) {\n    var reader;\n    reader = new FileReader();\n    reader.onload = function() {\n      var blob, bytes, img, url;\n      bytes = reader.result;\n      blob = new Blob([bytes], {\n        type: file.type\n      });\n      url = URL.createObjectURL(blob);\n      img = new Image();\n      img.onload = function() {\n        entry.content = img;\n        img.url = url;\n        img.bytes = bytes;\n        img.type = file.type;\n        return onLoad();\n      };\n      return img.src = url;\n    };\n    return reader.readAsArrayBuffer(file);\n  };\n  readText = function(entry, file, onLoad) {\n    var reader;\n    reader = new FileReader();\n    reader.onload = function() {\n      entry.content = reader.result;\n      return onLoad();\n    };\n    return reader.readAsText(file);\n  };\n  exports.readImage = function(onLoad) {\n    var input;\n    return input = $('<input type=\"file\">').attr('accept', 'image/*').change((function(_this) {\n      return function() {\n        var entry, file;\n        file = input.files[0];\n        entry = {};\n        return readImage(entry, file, function() {\n          return onLoad(entry.content, file.name);\n        });\n      };\n    })(this)).click()[0];\n  };\n  exports.read = function(accept, onLoad) {\n    var input;\n    return input = $('<input type=\"file\">').attr('accept', accept).change((function(_this) {\n      return function() {\n        var file, reader;\n        file = input.files[0];\n        reader = new FileReader();\n        reader.onload = function() {\n          return onLoad(reader.result, file);\n        };\n        return reader.readAsArrayBuffer(file);\n      };\n    })(this)).click()[0];\n  };\n  exports.openDir = function(onLoad) {\n    var input;\n    return input = $('<input type=\"file\" webkitdirectory=\"true\">').change((function(_this) {\n      return function() {\n        var count, entry, ext, file, loaded, name, path, result, _i, _len, _ref, _ref1;\n        result = [];\n        count = 0;\n        loaded = 0;\n        _ref = input.files;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          file = _ref[_i];\n          path = (_ref1 = file.webkitRelativePath) != null ? _ref1 : file.name;\n          ext = path.split('.').pop().toLowerCase();\n          name = path.split('/').pop();\n          entry = {\n            path: path,\n            ext: ext,\n            type: file.type,\n            name: name\n          };\n          result.push(entry);\n          switch (ext) {\n            case 'jpeg':\n            case 'jpg':\n            case 'png':\n            case 'gif':\n              count += 1;\n              readImage(entry, file, function() {\n                loaded += 1;\n                if (loaded === count) {\n                  return onLoad(result);\n                }\n              });\n              break;\n            case 'dae':\n              count += 1;\n              readText(entry, file, function() {\n                loaded += 1;\n                if (loaded === count) {\n                  return onLoad(result);\n                }\n              });\n          }\n        }\n        if (loaded === count) {\n          return onLoad(result);\n        }\n      };\n    })(this)).click()[0];\n  };\n  exports.save = function(name, data, mime) {\n    var blob, event, link, url;\n    if (mime == null) {\n      mime = 'application/octet-stream';\n    }\n    if (data instanceof Blob) {\n      blob = data;\n    } else {\n      blob = new Blob([data], {\n        type: mime\n      });\n    }\n    url = URL.createObjectURL(blob);\n    link = document.createElement('a');\n    link.download = name;\n    link.href = url;\n    event = document.createEvent('MouseEvents');\n    event.initMouseEvent('click', true, false, window, 0, 0, 0, 0, false, false, false, false, 0, null);\n    return link.dispatchEvent(event);\n  };\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/sphere.coffee":{"modified":1438675115674,"content":"sys.defModule('/sphere', function(exports, require, fs) {\n  var dump, faces, icosahedron, midp, normalize, octahedron, phi, pi, sphere, subdivide, v1, v10, v11, v12, v2, v3, v4, v5, v6, v7, v8, v9, vxm, vxp, vym, vyp, vzm, vzp;\n  pi = Math.PI;\n  midp = function(v1, v2) {\n    var x1, x2, x3, y1, y2, y3, z1, z2, z3;\n    x1 = v1[0];\n    y1 = v1[1];\n    z1 = v1[2];\n    x2 = v2[0];\n    y2 = v2[1];\n    z2 = v2[2];\n    x3 = (x1 + x2) / 2;\n    y3 = (y1 + y2) / 2;\n    z3 = (z1 + z2) / 2;\n    return [x3, y3, z3];\n  };\n  normalize = function(faces, r) {\n    var face, l, new_face, result, vertex, x, y, z, _i, _j, _len, _len1;\n    if (r == null) {\n      r = 1;\n    }\n    result = [];\n    for (_i = 0, _len = faces.length; _i < _len; _i++) {\n      face = faces[_i];\n      new_face = [];\n      result.push(new_face);\n      for (_j = 0, _len1 = face.length; _j < _len1; _j++) {\n        vertex = face[_j];\n        x = vertex[0];\n        y = vertex[1];\n        z = vertex[2];\n        l = Math.sqrt(x * x + y * y + z * z);\n        new_face.push([(r * x) / l, (r * y) / l, (r * z) / l]);\n      }\n    }\n    return result;\n  };\n  subdivide = function(faces) {\n    var face, result, v0, v1, v2, va, vb, vc, _i, _len;\n    result = [];\n    for (_i = 0, _len = faces.length; _i < _len; _i++) {\n      face = faces[_i];\n      v0 = face[0];\n      v1 = face[1];\n      v2 = face[2];\n      va = midp(v0, v1);\n      vb = midp(v1, v2);\n      vc = midp(v2, v0);\n      result.push([v0, va, vc], [va, v1, vb], [vc, vb, v2], [va, vb, vc]);\n    }\n    return result;\n  };\n  phi = (1 + Math.sqrt(5)) / 2;\n  v1 = [1, phi, 0];\n  v2 = [-1, phi, 0];\n  v3 = [0, 1, phi];\n  v4 = [0, 1, -phi];\n  v5 = [phi, 0, 1];\n  v6 = [-phi, 0, 1];\n  v7 = [-phi, 0, -1];\n  v8 = [phi, 0, -1];\n  v9 = [0, -1, phi];\n  v10 = [0, -1, -phi];\n  v11 = [-1, -phi, 0];\n  v12 = [1, -phi, 0];\n  faces = [[v1, v2, v3], [v2, v1, v4], [v1, v3, v5], [v2, v6, v3], [v2, v7, v6], [v2, v4, v7], [v1, v5, v8], [v1, v8, v4], [v9, v3, v6], [v3, v9, v5], [v4, v10, v7], [v4, v8, v10], [v6, v7, v11], [v6, v11, v9], [v7, v10, v11], [v5, v12, v8], [v12, v5, v9], [v12, v10, v8], [v11, v12, v9], [v12, v11, v10]];\n  icosahedron = normalize(faces);\n  vxp = [1, 0, 0];\n  vxm = [-1, 0, 0];\n  vyp = [0, 1, 0];\n  vym = [0, -1, 0];\n  vzp = [0, 0, 1];\n  vzm = [0, 0, -1];\n  faces = [[vzp, vxp, vyp], [vxm, vzp, vyp], [vyp, vxp, vzm], [vyp, vzm, vxm], [vym, vxp, vzp], [vym, vzp, vxm], [vzm, vxp, vym], [vxm, vzm, vym]];\n  octahedron = normalize(faces);\n  dump = function(faces) {\n    var face, l, result, vertex, x, y, z, _i, _j, _len, _len1;\n    result = [];\n    for (_i = 0, _len = faces.length; _i < _len; _i++) {\n      face = faces[_i];\n      for (_j = 0, _len1 = face.length; _j < _len1; _j++) {\n        vertex = face[_j];\n        x = vertex[0];\n        y = vertex[1];\n        z = vertex[2];\n        l = Math.sqrt(x * x + y * y + z * z);\n        result.push(x, y, z, x / l, y / l, z / l);\n      }\n    }\n    return result;\n  };\n  sphere = function(template, subdivisions) {\n    var i, _i;\n    if (subdivisions == null) {\n      subdivisions = 3;\n    }\n    for (i = _i = 0; 0 <= subdivisions ? _i < subdivisions : _i > subdivisions; i = 0 <= subdivisions ? ++_i : --_i) {\n      template = subdivide(template);\n      template = normalize(template);\n    }\n    return template;\n  };\n  exports.octahedron = function(subdivisions) {\n    var result;\n    result = sphere(octahedron, subdivisions);\n    return dump(normalize(result));\n  };\n  exports.icosahedron = function(subdivisions) {\n    var result;\n    result = sphere(icosahedron, subdivisions);\n    return dump(normalize(result));\n  };\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/environment/hdr.coffee":{"modified":1438857949550,"content":"sys.defModule('/environment/hdr', function(exports, require, fs) {\n  var resize, smoothstep;\n  smoothstep = function(edge0, edge1, x) {\n    x = (x - edge0) / (edge1 - edge0);\n    x = Math.min(Math.max(0, x), 1);\n    return x * x * x * (x * (x * 6 - 15) + 10);\n  };\n  resize = function(data, width, height, targetWidth, targetHeight) {\n    var a, ab, ag, ar, aw, b, g, get, getNearest, kHeight, kMax, kWidth, kX, kY, l, put, r, result, startTime, weight, x, xRatio, y, yRatio, _i, _j, _k, _l, _ref;\n    startTime = performance.now();\n    xRatio = width / targetWidth;\n    yRatio = height / targetHeight;\n    kWidth = Math.ceil(xRatio / 2);\n    kHeight = Math.ceil(yRatio / 2);\n    kMax = Math.max(kWidth, kHeight);\n    result = new Float32Array(targetWidth * targetHeight * 4);\n    get = function(x, y) {\n      x = Math.round(Math.min(Math.max(0, x), width - 1));\n      y = Math.round(Math.min(Math.max(0, y), height - 1));\n      return [data[(x + y * width) * 4 + 0], data[(x + y * width) * 4 + 1], data[(x + y * width) * 4 + 2], data[(x + y * width) * 4 + 3]];\n    };\n    put = function(x, y, r, g, b, a) {\n      if (a == null) {\n        a = 1;\n      }\n      result[(x + y * targetWidth) * 4 + 0] = r;\n      result[(x + y * targetWidth) * 4 + 1] = g;\n      result[(x + y * targetWidth) * 4 + 2] = b;\n      return result[(x + y * targetWidth) * 4 + 3] = a;\n    };\n    getNearest = function(s, t) {\n      return s = s * width;\n    };\n    for (y = _i = 0; 0 <= targetHeight ? _i < targetHeight : _i > targetHeight; y = 0 <= targetHeight ? ++_i : --_i) {\n      for (x = _j = 0; 0 <= targetWidth ? _j < targetWidth : _j > targetWidth; x = 0 <= targetWidth ? ++_j : --_j) {\n        ar = 0;\n        ag = 0;\n        ab = 0;\n        aw = 0;\n        for (kY = _k = -kHeight; -kHeight <= kHeight ? _k <= kHeight : _k >= kHeight; kY = -kHeight <= kHeight ? ++_k : --_k) {\n          for (kX = _l = -kWidth; -kWidth <= kWidth ? _l <= kWidth : _l >= kWidth; kX = -kWidth <= kWidth ? ++_l : --_l) {\n            l = Math.sqrt(kX * kX + kY * kY);\n            weight = smoothstep(0, kMax, l);\n            _ref = get((x + 0.5) * xRatio + kX, (y + 0.5) * yRatio + kY), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];\n            ar += r * weight;\n            ag += g * weight;\n            ab += b * weight;\n            aw += weight;\n          }\n        }\n        ar /= aw;\n        ag /= aw;\n        ab /= aw;\n        put(x, y, ar, ag, ab);\n      }\n    }\n    console.log(performance.now() - startTime);\n    return result;\n  };\n  exports.parse = function(array) {\n    var b, component, e, find, g, getInt, getString, headerEnd, height, heightStart, i, idx, num, pixelCount, pop, r, rgba, rgbe, size, startTime, v, value, width, widthStart, x, y, _i, _j, _k, _l, _m, _ref;\n    array = new Uint8Array(array);\n    getString = function(index, length) {\n      var i, result, _i;\n      result = '';\n      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {\n        result += String.fromCharCode(array[index + i]);\n      }\n      return result;\n    };\n    find = function(index, str) {\n      if (index == null) {\n        index = 0;\n      }\n      while (getString(index, str.length) !== str && index < array.length) {\n        index += 1;\n      }\n      if (index >= array.length) {\n        return null;\n      } else {\n        return {\n          start: index,\n          end: index + str.length\n        };\n      }\n    };\n    getInt = function(index) {\n      var result, start, str;\n      start = index;\n      result = '';\n      str = getString(index, 1);\n      while (str.match(/\\d/)) {\n        result += str;\n        index += 1;\n        str = getString(index, 1);\n      }\n      return {\n        start: start,\n        end: index + 1,\n        result: parseInt(result, 10)\n      };\n    };\n    headerEnd = find(0, '\\n\\n');\n    heightStart = find(headerEnd.end, '-Y ');\n    height = getInt(heightStart.end);\n    widthStart = find(height.end, '+X ');\n    width = getInt(widthStart.end);\n    size = {\n      x: width.result,\n      y: height.result\n    };\n    rgbe = new Uint8Array(size.x * size.y * 4);\n    idx = width.end;\n    pop = function() {\n      return array[idx++];\n    };\n    startTime = performance.now();\n    for (y = _i = 0, _ref = size.y; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {\n      pop();\n      pop();\n      pop();\n      pop();\n      for (component = _j = 0; _j < 4; component = ++_j) {\n        x = 0;\n        while (x < size.x) {\n          num = pop();\n          if (num <= 128) {\n            for (i = _k = 0; 0 <= num ? _k < num : _k > num; i = 0 <= num ? ++_k : --_k) {\n              rgbe[(y * size.x + x) * 4 + component] = pop();\n              x += 1;\n            }\n          } else {\n            value = pop();\n            num -= 128;\n            for (i = _l = 0; 0 <= num ? _l < num : _l > num; i = 0 <= num ? ++_l : --_l) {\n              rgbe[(y * size.x + x) * 4 + component] = value;\n              x += 1;\n            }\n          }\n        }\n      }\n    }\n    pixelCount = size.x * size.y * 4;\n    rgba = new Float32Array(pixelCount);\n    for (i = _m = 0; _m < pixelCount; i = _m += 4) {\n      r = rgbe[i + 0];\n      g = rgbe[i + 1];\n      b = rgbe[i + 2];\n      e = rgbe[i + 3];\n      v = Math.pow(2.0, e - 128.0) / 255.0;\n      rgba[i + 0] = r * v;\n      rgba[i + 1] = g * v;\n      rgba[i + 2] = b * v;\n      rgba[i + 3] = 1;\n    }\n    if (size.x <= 4096) {\n      return {\n        bytes: rgba,\n        width: size.x,\n        height: size.y\n      };\n    } else {\n      return {\n        bytes: resize(rgba, size.x, size.y, 4096, 2048),\n        width: 4096,\n        height: 2048\n      };\n    }\n  };\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/environment/lookup.shader":{"modified":1438678166750,"content":"sys.defFile(\"/environment/lookup.shader\", \"#file /environment/lookup.shader\\nuniform sampler2D textureEnv;\\nvec3 textureRectEnv(vec3 normal){\\n    vec2 dir = normalize(normal.xz);\\n    vec2 texcoord = vec2(\\n        atan(-dir.x, -dir.y)/TAU+0.5,\\n        acos(normal.y)/PI\\n    );\\n    return texture2D(textureEnv, texcoord).rgb;\\n}\");"},"/root/www/codeflow/webgl/envmapper3/src/environment/module.coffee":{"modified":1444849380690,"content":"sys.defModule('/environment/module', function(exports, require, fs) {\n  var Environment, fileSystem, hdr;\n  hdr = require('hdr');\n  fileSystem = require('/file-system');\n  exports = Environment = (function() {\n    function Environment(app) {\n      this.app = app;\n      this.texture = this.app.fw.texture2D({\n        width: 1,\n        height: 1,\n        filter: 'linear',\n        clamp: 'edge',\n        type: this.app.fw.usableFloat\n      });\n      this.lookup = fs.open('lookup.shader');\n    }\n\n    Environment.prototype.setUniformsOn = function(state) {\n      return state.sampler('textureEnv', this.texture);\n    };\n\n    Environment.prototype.openHDR = function() {\n      return fileSystem.read('.hdr', (function(_this) {\n        return function(array, file) {\n          var data, name;\n          name = file.name.split('.');\n          name.pop();\n          _this.filename = name.join('.');\n          data = hdr.parse(array);\n          _this.texture.dataSized(data.bytes, data.width, data.height);\n          return _this.app.emit('environment-update');\n        };\n      })(this));\n    };\n\n    return Environment;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/octahedral.shader":{"modified":1439583748234,"content":"sys.defFile(\"/octahedral.shader\", \"#file /octahedral.shader\\n#define sectorize(value) step(0.0, (value))*2.0-1.0\\n#define sum(value) dot(clamp((value), 1.0, 1.0), (value))\\n#define PI 3.141592653589793\\n\\nvec2 normalToUvRectOct(vec3 normal){\\n    normal /= sum(abs(normal));\\n    if(normal.y > 0.0){\\n        return normal.xz*0.5+0.5;\\n    }\\n    else{\\n        vec2 suv = sectorize(normal.xz);\\n        vec2 uv = suv-suv*abs(normal.zx);\\n        return uv*0.5+0.5;\\n    }\\n}\\n\\nvec3 uvToNormalRectOct(vec2 uv){\\n    uv = uv*2.0-1.0;\\n    vec2 auv = abs(uv);\\n    vec2 suv = sectorize(uv);\\n    float l = sum(auv);\\n\\n    if(l > 1.0){\\n        uv = (1.0-auv.ts)*suv;\\n    }\\n\\n    return normalize(vec3(uv.s,1.0-l,uv.t));\\n}\\n\\nvec2 normalToUvSphOct(vec3 normal){\\n    normal = normalize(normal);\\n    vec3 aNorm = abs(normal);\\n    vec3 sNorm = sectorize(normal);\\n\\n    vec2 dir = max(aNorm.xz, 1e-20);\\n    float orient = atan(dir.x, dir.y)/(PI*0.5);\\n\\n    dir = max(vec2(aNorm.y, length(aNorm.xz)), 1e-20);\\n    float pitch = atan(dir.y, dir.x)/(PI*0.5);\\n\\n    vec2 uv = vec2(sNorm.x*orient, sNorm.z*(1.0-orient))*pitch;\\n\\n    if(normal.y < 0.0){\\n        uv = sNorm.xz - abs(uv.ts)*sNorm.xz;\\n    }\\n    return uv*0.5+0.5;\\n}\\n\\nvec3 uvToNormalSphOct(vec2 uv){\\n    uv = uv*2.0-1.0;\\n    vec2 suv = sectorize(uv);\\n    float pitch = sum(abs(uv))*PI*0.5;\\n\\n    if(sum(abs(uv)) > 1.0){\\n        uv = (1.0-abs(uv.ts))*suv;\\n    }\\n\\n    float orient = (abs(uv.s)/sum(abs(uv)))*PI*0.5;\\n    float sOrient = sin(orient);\\n    float cOrient = cos(orient);\\n    float sPitch = sin(pitch);\\n    float cPitch = cos(pitch);\\n\\n    return vec3(\\n        sOrient*suv.s*sPitch,\\n        cPitch,\\n        cOrient*suv.t*sPitch\\n    );\\n}\\n\\n#define uvToNormal uvToNormalSphOct\\n#define normalToUv normalToUvSphOct\\n//#define uvToNormal uvToNormalRectOct\\n//#define normalToUv normalToUvRectOct\");"},"/root/www/codeflow/webgl/envmapper3/src/accumulator/module.coffee":{"modified":1444911440518,"content":"sys.defModule('/accumulator/module', function(exports, require, fs) {\n  var Accumulator, Accumulators, lambertExponent, normalize;\n  lambertExponent = function(angle) {\n    var cos, cutoff, cutoffAngle, exp, modifiedAngle;\n    angle = angle / 180;\n    cutoff = 0.02;\n    cutoffAngle = Math.acos(cutoff);\n    modifiedAngle = angle * cutoffAngle;\n    cos = Math.cos(modifiedAngle);\n    exp = Math.log(cutoff) / Math.log(cos);\n    return exp;\n  };\n  normalize = function(data, exposure) {\n    var a, b, g, i, pixels, r, result, _i;\n    pixels = data.length / 4;\n    result = new Float64Array(pixels * 3);\n    for (i = _i = 0; 0 <= pixels ? _i < pixels : _i > pixels; i = 0 <= pixels ? ++_i : --_i) {\n      r = data[i * 4 + 0] * exposure;\n      g = data[i * 4 + 1] * exposure;\n      b = data[i * 4 + 2] * exposure;\n      a = data[i * 4 + 3];\n      result[i * 3 + 0] = r / a;\n      result[i * 3 + 1] = g / a;\n      result[i * 3 + 2] = b / a;\n    }\n    return result;\n  };\n  Accumulator = (function() {\n    function Accumulator(app, size, updateShader, copyShader) {\n      var i, max, _i;\n      this.app = app;\n      this.size = size;\n      this.levels = [];\n      this.levels.push(this.app.fw.state({\n        framebuffer: {\n          color: {\n            width: this.size,\n            height: this.size,\n            filter: 'linear',\n            clamp: 'edge',\n            type: this.app.fw.usableFloat\n          }\n        },\n        shader: updateShader,\n        blend: 'add'\n      }));\n      max = Math.log2(this.size) - 1;\n      for (i = _i = max; max <= 0 ? _i <= 0 : _i >= 0; i = max <= 0 ? ++_i : --_i) {\n        size = Math.pow(2, i);\n        this.levels.push(this.app.fw.state({\n          framebuffer: {\n            color: {\n              width: size,\n              height: size,\n              filter: 'linear',\n              clamp: 'edge',\n              type: this.app.fw.usableFloat\n            }\n          },\n          shader: copyShader\n        }));\n      }\n      this.app.on('environment-update', (function(_this) {\n        return function() {\n          return _this.clear();\n        };\n      })(this));\n    }\n\n    Accumulator.prototype.bind = function(unit) {\n      if (unit == null) {\n        unit = 0;\n      }\n      return this.levels[0].bind(unit);\n    };\n\n    Accumulator.prototype.update = function(angle) {\n      var exponent, i, _i, _ref;\n      exponent = lambertExponent(angle);\n      this.levels[0].float('angle', angle).float('lambertExponent', exponent).uniformSetter(this.app.environment).vec2('size', this.size, this.size).draw();\n      for (i = _i = 1, _ref = this.levels.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {\n        this.levels[i].sampler('source', this.levels[i - 1]).draw();\n      }\n      return this.generateMips();\n    };\n\n    Accumulator.prototype.generateMips = function() {\n      return null;\n    };\n\n    Accumulator.prototype.clear = function() {\n      this.levels[0].clearColor(0, 0, 0, 0);\n      return this.generateMips();\n    };\n\n    return Accumulator;\n\n  })();\n  exports = Accumulators = (function() {\n    function Accumulators(app) {\n      var size, _i, _len, _ref;\n      this.app = app;\n      this.updateShader = this.app.fw.shader([fs.open('/octahedral.shader'), this.app.environment.lookup, fs.open('update.shader')]);\n      this.copyShader = this.app.fw.shader(fs.open('copy.shader'));\n      this.accumulators = [];\n      _ref = [128, 128, 128, 128, 256, 512, 1024];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        size = _ref[_i];\n        this.accumulators.push(new Accumulator(this.app, size, this.updateShader, this.copyShader));\n      }\n      this.specular = this.app.fw.state({\n        framebuffer: {\n          color: {\n            width: 3000,\n            height: 1292 + 1026,\n            filter: 'linear',\n            clamp: 'edge',\n            type: this.app.fw.usableFloat\n          }\n        },\n        shader: fs.open('padd.shader')\n      });\n    }\n\n    Accumulators.prototype.update = function() {\n      var accumulator, angle, basis, hOffset, i, i2, j, j0, level, minAngle, offset0, offset1, size, vOffset, _i, _j, _len, _len1, _ref, _ref1, _results;\n      this.updateShader.vec2('samples', this.app.samples.data());\n      minAngle = 360 / 512;\n      basis = Math.pow(180 / minAngle, 1.0 / (this.accumulators.length - 1));\n      _ref = this.accumulators;\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        accumulator = _ref[i];\n        angle = 180 / Math.pow(basis, i);\n        accumulator.update(angle);\n      }\n      _ref1 = this.accumulators;\n      _results = [];\n      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {\n        accumulator = _ref1[i];\n        size = Math.max(128, Math.pow(2, i + 4));\n        offset0 = 130 * Math.min(i, 4);\n        i2 = Math.max(i - 4, 0);\n        offset1 = Math.pow(2, i2 + 8) - 256 + 2 * i2;\n        vOffset = offset0 + offset1;\n        _results.push((function() {\n          var _k, _len2, _ref2, _results1;\n          _ref2 = accumulator.levels;\n          _results1 = [];\n          for (j = _k = 0, _len2 = _ref2.length; _k < _len2; j = ++_k) {\n            level = _ref2[j];\n            size = Math.max(128, Math.pow(2, i + 4));\n            size /= Math.pow(2, j);\n            j0 = accumulator.levels.length - j - 1;\n            hOffset = Math.pow(2, j0) - 1 + 2 * j0;\n            _results1.push(this.specular.viewport(hOffset, vOffset, size + 2, size + 2).float('size', size + 2).sampler('source', level).draw());\n          }\n          return _results1;\n        }).call(this));\n      }\n      return _results;\n    };\n\n    Accumulators.prototype.bind = function(unit) {\n      if (unit == null) {\n        unit = 0;\n      }\n      return this.specular.bind(unit);\n    };\n\n    Accumulators.prototype.get = function(idx) {\n      return this.accumulators[idx];\n    };\n\n    Accumulators.prototype.blit = function() {\n      return this.specular.blit();\n    };\n\n    Accumulators.prototype.save = function(exposure) {\n      var result, slice, texture, _i, _len, _ref;\n      result = [];\n      _ref = this.accumulators;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        slice = _ref[_i];\n        texture = slice.levels[0];\n        result.push({\n          size: texture.width(),\n          data: normalize(texture.readPixels(), exposure)\n        });\n      }\n      return result;\n    };\n\n    Accumulators.prototype.getAvg = function() {\n      var a, b, g, r, result, slice, _i, _len, _ref, _ref1;\n      result = [];\n      _ref = this.accumulators;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        slice = _ref[_i];\n        _ref1 = slice.levels[slice.levels.length - 1].readPixels(), r = _ref1[0], g = _ref1[1], b = _ref1[2], a = _ref1[3];\n        result.push([r / a, g / a, b / a]);\n      }\n      return result;\n    };\n\n    return Accumulators;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/accumulator/update.shader":{"modified":1460568114296,"content":"sys.defFile(\"/accumulator/update.shader\", \"#file /accumulator/update.shader\\nvarying vec2 texcoord;\\n\\nvertex:\\n    attribute vec2 position;\\n    void main(){\\n        texcoord = position*0.5+0.5;\\n        gl_Position = vec4(position, 0, 1);\\n    }\\n\\nfragment:\\n    #define numSamples 50\\n    uniform vec2 samples[numSamples];\\n    uniform float angle;\\n    uniform float lambertExponent;\\n    uniform vec2 size;\\n\\n    /*\\n    vec3 getDir(vec2 rnd, vec3 normal){\\n        float r = rnd.s * 2.0 * PI;\\n        float z = rnd.t*2.0-1.0;\\n        float scale = sqrt(1.0-z*z);\\n        vec3 dir = vec3(cos(r)*scale, sin(r)*scale, z);\\n        if(dot(dir, normal) < 0.0){\\n            return -dir;\\n        }\\n        else{\\n            return dir;\\n        }\\n    }\\n    */\\n\\n    vec3 getDir(vec2 rnd, vec3 normal){\\n        if(angle >= 20.0){\\n            float r = rnd.s * 2.0 * PI;\\n            float z = rnd.t*2.0-1.0;\\n            float scale = sqrt(1.0-z*z);\\n            vec3 dir = vec3(cos(r)*scale, sin(r)*scale, z);\\n            if(dot(normal, dir) < 0.0){\\n                dir = -dir;\\n            }\\n            return dir;\\n        }\\n        else{\\n            vec3 tangent = normalize(cross(vec3(0,1,0), normal));\\n            vec3 cotangent = normalize(cross(tangent, normal));\\n\\n            //float a = (clamp(angle, 0.0, 90.0)/90.0)*PIH;\\n            float a = (clamp(angle, 0.0, 90.0)/90.0)*PIH;\\n            float z = mix(1.0, cos(a), rnd.t);\\n            //float z = rnd.t*2.0-1.0;\\n            float r = rnd.s * TAU;\\n            float scale = sqrt(1.0-z*z);\\n            float x = cos(r)*scale;\\n            float y = sin(r)*scale;\\n\\n            vec3 dir = normalize(\\n                x*tangent + \\n                y*cotangent +\\n                z*normal\\n            );\\n            return dir;\\n        }\\n    }\\n\\n    void main(){\\n        vec4 accum = vec4(0);\\n        vec3 normal = uvToNormal(texcoord);\\n        for(int i=0; i<numSamples; i++){\\n            vec3 dir = getDir(samples[i], normal);\\n            float lambert = max(0.0, dot(normal, dir));\\n            float weight = pow(lambert, lambertExponent);\\n            vec3 color = textureRectEnv(dir);\\n            accum += vec4(color*weight, weight);\\n        }\\n        gl_FragColor = accum;\\n\\n        /*\\n        // test pattern\\n        vec2 coord = texcoord*2.0-1.0;\\n        coord = step(0.0, coord);\\n        float l = sum(abs(texcoord*2.0-1.0));\\n        if(l > 1.0){\\n            gl_FragColor.rgb = vec3(coord.s, 1, coord.t)*(0.5+(l-1.0)*0.5);\\n        }\\n        else{\\n            gl_FragColor.rgb = vec3(coord.s, 0, coord.t)*(0.5+l*0.5);\\n        }\\n        gl_FragColor.a = 1.0;\\n        */\\n    }\");"},"/root/www/codeflow/webgl/envmapper3/src/camera/module.coffee":{"modified":1439558969058,"content":"sys.defModule('/camera/module', function(exports, require, fs) {\n  var ApproxValue, ApproxVector, Camera, Pointer, _ref;\n  Pointer = require('pointer');\n  _ref = require('values'), ApproxValue = _ref.ApproxValue, ApproxVector = _ref.ApproxVector;\n  exports = Camera = (function() {\n    function Camera(app) {\n      this.app = app;\n      this.fw = this.app.fw;\n      this.proj = this.fw.mat4();\n      this.invProj = this.fw.mat4();\n      this.view = this.fw.mat4();\n      this.invView = this.fw.mat4();\n      this.rot = this.fw.mat3();\n      this.invRot = this.fw.mat3();\n      this.dt = 1 / 120;\n      this.rotation = new ApproxValue(0, this.dt, 15);\n      this.pitch = new ApproxValue(30, this.dt, 15);\n      this.zoom = new ApproxValue(2, this.dt, 5);\n      this.up = this.fw.vec3();\n      this.right = this.fw.vec3();\n      this.position = new ApproxVector(0, 0, 0, this.dt, 10);\n      this.pointer = new Pointer(this.app, this.fw.canvas);\n      this.limits = {\n        rotation: {\n          min: null,\n          max: null\n        },\n        pitch: {\n          min: null,\n          max: null\n        },\n        zoom: {\n          min: null,\n          max: null\n        }\n      };\n      this.positionLocked = false;\n      this.app.hub.on('pointer-wheel', (function(_this) {\n        return function(value) {\n          var factor;\n          value /= 53;\n          factor = Math.pow(1.05, value);\n          return _this.zoom.multiply(factor);\n        };\n      })(this)).on('pointer-drag', (function(_this) {\n        return function(event) {\n          return _this.drag(event);\n        };\n      })(this));\n    }\n\n    Camera.prototype.drag = function(event) {\n      if (event.which === 1) {\n        return this.orient(event);\n      } else if (event.which === 3) {\n        return this.pan(event);\n      }\n    };\n\n    Camera.prototype.orient = function(event) {\n      this.rotation.add(event.screen.dx * 0.3);\n      return this.pitch.add(event.screen.dy * 0.3);\n    };\n\n    Camera.prototype.pan = function(event) {\n      var factor, x, y;\n      if (!this.positionLocked) {\n        this.invRot.mulVec3(this.up.set(0, 1, 0));\n        this.invRot.mulVec3(this.right.set(1, 0, 0));\n        factor = 0.01;\n        x = event.screen.dx;\n        y = event.screen.dy;\n        y = y * -factor;\n        x = x * factor;\n        this.position.add(this.up.x * y, this.up.y * y, this.up.z * y);\n        return this.position.add(this.right.x * x, this.right.y * x, this.right.z * x);\n      }\n    };\n\n    Camera.prototype.step = function() {\n      var f, now;\n      now = performance.now() / 1000;\n      if (this.time == null) {\n        this.time = now - 0.2;\n      }\n      if (now - this.time > 0.2) {\n        this.time = now - 0.2;\n      }\n      this.rotation.limit(this.limits.rotation.min, this.limits.rotation.max);\n      this.pitch.limit(this.limits.pitch.min, this.limits.pitch.max);\n      this.zoom.limit(this.limits.zoom.min, this.limits.zoom.max);\n      while (this.time < now) {\n        this.time += this.dt;\n        this.rotation.integrate();\n        this.pitch.integrate();\n        this.zoom.integrate();\n        this.position.integrate();\n      }\n      f = (this.time - now) / this.dt;\n      this.rotation.interpolate(f);\n      this.pitch.interpolate(f);\n      this.zoom.interpolate(f);\n      return this.position.interpolate(f);\n    };\n\n    Camera.prototype.update = function() {\n      var dist;\n      dist = this.zoom.get();\n      this.perspective(90, 0.01, 100);\n      this.step();\n      this.view.identity().translate(0, 0, -dist).rotatex(this.pitch.get()).rotatey(this.rotation.get()).translate(this.position.x.get(), this.position.y.get(), this.position.z.get());\n      this.view.invert(this.invView.identity());\n      this.view.toMat3Rot(this.rot.identity());\n      return this.invView.toMat3Rot(this.invRot.identity());\n    };\n\n    Camera.prototype.perspective = function(fov, near, far) {\n      var aspect;\n      if (fov == null) {\n        fov = 60;\n      }\n      if (near == null) {\n        near = 0.05;\n      }\n      if (far == null) {\n        far = 20;\n      }\n      aspect = this.fw.canvas.width / this.fw.canvas.height;\n      this.proj.identity().perspective(fov, aspect, near, far);\n      return this.invProj.identity().inversePerspective(fov, aspect, near, far);\n    };\n\n    Camera.prototype.setUniformsOn = function(state) {\n      state.mat4('proj', this.proj).mat4('invProj', this.invProj).mat4('view', this.view).mat4('invView', this.invView).mat3('rot', this.rot).mat3('invRot', this.invRot);\n      return this;\n    };\n\n    Camera.prototype.eyePos = function(dst) {\n      this.invView.mulVal4(0, 0, 0, 1, dst);\n      return this;\n    };\n\n    Camera.prototype.eyeDir = function(x, y, dst) {\n      this.invProj.mulVal4(x, y, 0, 1, dst);\n      this.invRot.mulVal3(dst.x, dst.y, dst.z, dst);\n      return this;\n    };\n\n    return Camera;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/camera/pointer.coffee":{"modified":1437977968326,"content":"var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nsys.defModule('/camera/pointer', function(exports, require, fs) {\n  var Pointer;\n  exports = Pointer = (function() {\n    function Pointer(core, elem) {\n      this.core = core;\n      this.elem = elem;\n      this.wheel = __bind(this.wheel, this);\n      this.context = __bind(this.context, this);\n      this.mousemove = __bind(this.mousemove, this);\n      this.mouseup = __bind(this.mouseup, this);\n      this.mousedown = __bind(this.mousedown, this);\n      this.hub = this.core.hub;\n      $(this.elem).bind('mousedown', this.mousedown).bind('mouseup', this.mouseup).bind('contextmenu', this.context).bind('wheel', this.wheel);\n      $(document).bind('mouseup', this.mouseup).bind('mousemove', this.mousemove);\n      this.down = false;\n      this.dragging = false;\n      this.pos = null;\n    }\n\n    Pointer.prototype.emit = function(type, x, y, dx, dy) {\n      if (x == null) {\n        x = this.pos[0];\n      }\n      if (y == null) {\n        y = this.pos[1];\n      }\n      return this.hub.emit(type, {\n        which: this.which,\n        screen: {\n          x: x,\n          y: x,\n          dx: dx,\n          dy: dy\n        },\n        device: {\n          x: (x / this.elem.clientWidth) * 2 - 1,\n          y: 1 - (y / this.elem.clientHeight) * 2,\n          dx: (dx / this.elem.clientWidth) * 2 - 1,\n          dy: 1 - (dy / this.elem.clientHeight) * 2\n        }\n      });\n    };\n\n    Pointer.prototype.mousedown = function(event) {\n      this.down = true;\n      this.which = event.which;\n      return this.pos = this.getPos(event);\n    };\n\n    Pointer.prototype.mouseup = function(event) {\n      if (this.down) {\n        this.down = false;\n        if (this.dragging) {\n          this.dragging = false;\n          return this.emit('pointer-drag-stop');\n        } else {\n          return this.emit('pointer-click');\n        }\n      }\n    };\n\n    Pointer.prototype.mousemove = function(event) {\n      var dx, dy, pos;\n      if (this.down) {\n        pos = this.getPos(event);\n        if (!this.dragging) {\n          this.emit('pointer-drag-start', pos[0], pos[1]);\n          this.dragging = true;\n        }\n        dx = pos[0] - this.pos[0];\n        dy = pos[1] - this.pos[1];\n        this.emit('pointer-drag', pos[0], pos[1], dx, dy);\n        return this.pos = pos;\n      }\n    };\n\n    Pointer.prototype.context = function(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      return false;\n    };\n\n    Pointer.prototype.getPos = function(event) {\n      var rect, x, y;\n      rect = this.elem.getBoundingClientRect();\n      x = event.clientX - rect.left;\n      y = event.clientY - rect.top;\n      return [x, y];\n    };\n\n    Pointer.prototype.wheel = function(event) {\n      var dy;\n      event.preventDefault();\n      event.stopPropagation();\n      event = event.originalEvent;\n      dy = event.deltaY;\n      if (event.deltaMode === 1) {\n        dy *= 17.6;\n      } else if (event.deltaMode === 2) {\n        dy *= document.body.offsetHeight;\n      }\n      return this.hub.emit('pointer-wheel', dy);\n    };\n\n    return Pointer;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/camera/values.coffee":{"modified":1437977968326,"content":"sys.defModule('/camera/values', function(exports, require, fs) {\n  var ApproxValue, ApproxVector;\n  exports.ApproxValue = ApproxValue = (function() {\n    function ApproxValue(value, dt, speed) {\n      this.value = value;\n      this.dt = dt;\n      this.speed = speed;\n      this.target = this.value;\n      this.last = this.value;\n      this.display = this.value;\n    }\n\n    ApproxValue.prototype.integrate = function() {\n      var delta;\n      delta = (this.target - this.value) * this.dt * this.speed;\n      this.last = this.value;\n      return this.value += delta;\n    };\n\n    ApproxValue.prototype.interpolate = function(f) {\n      return this.display = this.last * f + (1 - f) * this.value;\n    };\n\n    ApproxValue.prototype.get = function() {\n      return this.display;\n    };\n\n    ApproxValue.prototype.set = function(target) {\n      this.target = target;\n      return this;\n    };\n\n    ApproxValue.prototype.add = function(value, low, high) {\n      if (low == null) {\n        low = null;\n      }\n      if (high == null) {\n        high = null;\n      }\n      this.target += value;\n      return this.limit(low, high);\n    };\n\n    ApproxValue.prototype.multiply = function(value, low, high) {\n      if (low == null) {\n        low = null;\n      }\n      if (high == null) {\n        high = null;\n      }\n      this.target *= value;\n      return this.limit(low, high);\n    };\n\n    ApproxValue.prototype.hardset = function(value) {\n      this.value = value;\n      this.target = value;\n      this.last = value;\n      return this.display = value;\n    };\n\n    ApproxValue.prototype.limit = function(low, high) {\n      if ((low != null) && this.target < low) {\n        this.target = low;\n      }\n      if ((high != null) && this.target > high) {\n        return this.target = high;\n      }\n    };\n\n    return ApproxValue;\n\n  })();\n  exports.ApproxVector = ApproxVector = (function() {\n    function ApproxVector(x, y, z, dt, speed) {\n      this.x = new ApproxValue(x, dt, speed);\n      this.y = new ApproxValue(y, dt, speed);\n      this.z = new ApproxValue(z, dt, speed);\n    }\n\n    ApproxVector.prototype.integrate = function() {\n      this.x.integrate();\n      this.y.integrate();\n      return this.z.integrate();\n    };\n\n    ApproxVector.prototype.interpolate = function(f) {\n      this.x.interpolate(f);\n      this.y.interpolate(f);\n      return this.z.interpolate(f);\n    };\n\n    ApproxVector.prototype.set = function(x, y, z) {\n      this.x.set(x);\n      this.y.set(y);\n      return this.z.set(z);\n    };\n\n    ApproxVector.prototype.hardset = function(x, y, z) {\n      this.x.hardset(x);\n      this.y.hardset(y);\n      return this.z.hardset(z);\n    };\n\n    ApproxVector.prototype.get = function() {\n      return [this.x.get(), this.y.get(), this.z.get()];\n    };\n\n    ApproxVector.prototype.add = function(x, y, z) {\n      this.x.add(x);\n      this.y.add(y);\n      return this.z.add(z);\n    };\n\n    ApproxVector.prototype.limit = function(xmin, xmax, ymin, ymax, zmin, zmax) {\n      if (this.x.target < xmin) {\n        this.x.target = xmin;\n      } else if (this.x.target > xmax) {\n        this.x.target = xmax;\n      }\n      if (this.y.target < ymin) {\n        this.y.target = ymin;\n      } else if (this.y.target > ymax) {\n        this.y.target = ymax;\n      }\n      if (this.z.target < zmin) {\n        return this.z.target = zmin;\n      } else if (this.z.target > zmax) {\n        return this.z.target = zmax;\n      }\n    };\n\n    return ApproxVector;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/events.coffee":{"modified":1438700065010,"content":"sys.defModule('/events', function(exports, require, fs) {\n  var Events;\n  exports = Events = (function() {\n    function Events() {\n      this.handlers = {};\n    }\n\n    Events.prototype.on = function(name, callback) {\n      var handlers, idx;\n      handlers = this.handlers[name];\n      if (handlers == null) {\n        handlers = this.handlers[name] = [];\n      }\n      idx = handlers.indexOf(callback);\n      if (idx === -1) {\n        handlers.push(callback);\n      } else {\n        handlers.push(handlers.splice(idx, 1));\n      }\n      return this;\n    };\n\n    Events.prototype.off = function(nameOrCallback, callback) {\n      var handlers, idx, name, _ref;\n      if (typeof nameOrCallback === 'function') {\n        name = null;\n        callback = nameOrCallback;\n      } else {\n        name = nameOrCallback;\n      }\n      if ((name != null) && (callback != null)) {\n        handlers = this.handlers[name];\n        idx = handlers.indexOf(callback);\n        if (idx !== -1) {\n          handlers.splice(idx, 1);\n        }\n      } else if (name != null) {\n        delete this.handlers[name];\n      } else if (callback != null) {\n        _ref = this.handlers;\n        for (name in _ref) {\n          handlers = _ref[name];\n          idx = handlers.indexOf(callback);\n          if (idx !== -1) {\n            handlers.splice(idx, 1);\n          }\n        }\n      }\n      return this;\n    };\n\n    Events.prototype.emit = function(name, data) {\n      var handler, handlers, _i, _len;\n      handlers = this.handlers[name];\n      if (handlers != null) {\n        for (_i = 0, _len = handlers.length; _i < _len; _i++) {\n          handler = handlers[_i];\n          handler(data);\n        }\n      }\n      return this;\n    };\n\n    return Events;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/get-buffer.coffee":{"modified":1438707032642,"content":"sys.defModule('/get-buffer', function(exports, require, fs) {\n  exports = function(url, handlers) {\n    var compressed, contentLength, entityLength, initiated, xhr;\n    if (typeof handlers === 'function') {\n      handlers = {\n        load: handlers,\n        init: function() {},\n        progress: function() {}\n      };\n    }\n    compressed = false;\n    contentLength = null;\n    entityLength = null;\n    initiated = false;\n    xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function() {\n      return handlers.load(xhr.response);\n    };\n    xhr.onreadystatechange = function(event) {\n      if (xhr.readyState === xhr.HEADERS_RECEIVED) {\n        compressed = xhr.getResponseHeader('Content-Encoding') != null;\n        contentLength = xhr.getResponseHeader('Content-Length');\n        entityLength = xhr.getResponseHeader('X-Entity-Length');\n        if (contentLength != null) {\n          contentLength = parseFloat(contentLength);\n        }\n        if (entityLength != null) {\n          return entityLength = parseFloat(entityLength);\n        }\n      }\n    };\n    xhr.onprogress = function(event) {\n      var loaded, total;\n      if (compressed) {\n        if (entityLength != null) {\n          loaded = event.loaded;\n          total = entityLength;\n        } else {\n          total = null;\n          loaded = null;\n        }\n      } else {\n        if (event.lengthComputable) {\n          loaded = event.loaded;\n          total = event.total;\n        } else {\n          loaded = null;\n          total = null;\n        }\n      }\n      if (!initiated) {\n        initiated = true;\n        handlers.init(total);\n      }\n      if (loaded != null) {\n        return handlers.progress(loaded);\n      }\n    };\n    return xhr.send();\n  };\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/samples.coffee":{"modified":1439582462110,"content":"sys.defModule('/samples', function(exports, require, fs) {\n  var Halton2D, Samples, halton, rnd;\n  rnd = function() {\n    return ROT.RNG.getUniform();\n  };\n  halton = function(i, base) {\n    var f, result;\n    result = 0;\n    f = 1 / base;\n    while (i > 0) {\n      result = result + f * (i % base);\n      i = Math.floor(i / base);\n      f = f / base;\n    }\n    return result;\n  };\n  Halton2D = (function() {\n    function Halton2D(baseX, baseY, i) {\n      this.baseX = baseX != null ? baseX : 2;\n      this.baseY = baseY != null ? baseY : 3;\n      this.i = i != null ? i : 100;\n      this.initial = this.i;\n    }\n\n    Halton2D.prototype.get = function(index) {\n      var i, x, y;\n      i = index != null ? index : this.i;\n      x = halton(i, this.baseX);\n      y = halton(i, this.baseY);\n      if (index == null) {\n        this.i += 1;\n      }\n      return [x, y];\n    };\n\n    Halton2D.prototype.index = function() {\n      return this.i;\n    };\n\n    Halton2D.prototype.reset = function() {\n      return this.i = this.initial;\n    };\n\n    return Halton2D;\n\n  })();\n  exports = Samples = (function() {\n    function Samples(app) {\n      var num;\n      this.app = app;\n      num = 50;\n      this.samples = new Float32Array(num * 2);\n      this.hIndex = 0;\n      this.app.on('environment-update', (function(_this) {\n        return function() {\n          return _this.hIndex = 0;\n        };\n      })(this));\n    }\n\n    Samples.prototype.randomVec = function(idx) {\n      this.samples[idx + 0] = rnd();\n      return this.samples[idx + 1] = rnd();\n    };\n\n    Samples.prototype.haltonVec = function(idx) {\n      this.samples[idx + 0] = halton(this.hIndex, 2);\n      this.samples[idx + 1] = halton(this.hIndex, 3);\n      return this.hIndex += 1;\n    };\n\n    Samples.prototype.generate = function() {\n      var i, _i, _ref, _results;\n      _results = [];\n      for (i = _i = 0, _ref = this.samples.length; _i < _ref; i = _i += 2) {\n        _results.push(this.randomVec(i));\n      }\n      return _results;\n    };\n\n    Samples.prototype.data = function() {\n      return this.samples;\n    };\n\n    return Samples;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/accumulator/padd.shader":{"modified":1444471321710,"content":"sys.defFile(\"/accumulator/padd.shader\", \"#file /accumulator/padd.shader\\nvarying vec2 texcoord;\\n\\nvertex:\\n    attribute vec2 position;\\n    void main(){\\n        texcoord = position*0.5+0.5;\\n        gl_Position = vec4(position, 0, 1);\\n    }\\n\\nfragment:\\n    uniform sampler2D source;\\n    uniform float size;\\n    void main(){\\n        //vec2 coord = gl_FragCoord.st;\\n        vec2 coord = texcoord*size;\\n\\n        vec2 acoord = abs(coord-size*0.5);\\n        float limit = size*0.5-1.0;\\n        vec2 sourceCoord = clamp(coord-1.0, 0.5, size-2.5);\\n        vec2 uv = sourceCoord/(size-2.0);\\n\\n        if(acoord.x > limit && acoord.y > limit){\\n            uv = 1.0 - uv;\\n        }\\n        else if(acoord.x > limit){\\n            uv.y = 1.0 - uv.y;\\n        }\\n        else if(acoord.y > limit){\\n            uv.x = 1.0 - uv.x;\\n        }\\n\\n        vec4 texel = texture2D(source, uv);\\n        gl_FragColor = vec4(texel.rgb/texel.a, 1);\\n    }\");"},"/root/www/codeflow/webgl/envmapper3/src/accumulator/copy.shader":{"modified":1438858367418,"content":"sys.defFile(\"/accumulator/copy.shader\", \"#file /accumulator/copy.shader\\nvarying vec2 texcoord;\\n\\nvertex:\\n    attribute vec2 position;\\n    void main(){\\n        texcoord = position*0.5+0.5;\\n        gl_Position = vec4(position, 0, 1);\\n    }\\n\\nfragment:\\n    uniform sampler2D source;\\n    void main(){\\n        gl_FragColor = texture2D(source, texcoord);\\n        //gl_FragColor = vec4(1,0,1,1);\\n    }\");"},"/root/www/codeflow/webgl/envmapper3/src/compression/module.coffee":{"modified":1454929042044,"content":"sys.defModule('/compression/module', function(exports, require, fs) {\n  var RGBtoXYLUM, XYLUMtoRGB, compress, compressBlock2, compressBlock4, decompress, decompressBlock2, decompressBlock4, minmax, saturate, scale, stream, unscale;\n  stream = require('stream');\n  saturate = function(value) {\n    if (value < 0) {\n      return 0;\n    } else if (value > 1) {\n      return 1;\n    } else {\n      return value;\n    }\n  };\n  minmax = function(values) {\n    var max, min, value, _i, _len;\n    min = max = values[0];\n    if (isNaN(min)) {\n      min = max = 0;\n    }\n    for (_i = 0, _len = values.length; _i < _len; _i++) {\n      value = values[_i];\n      if (isNaN(value)) {\n        value = 0;\n      }\n      max = Math.max(value, max);\n      min = Math.min(value, min);\n    }\n    return {\n      max: max,\n      min: min\n    };\n  };\n  scale = function(data, limit) {\n    var i, max, min, result, value, _i, _len, _ref;\n    _ref = minmax(data), min = _ref.min, max = _ref.max;\n    result = new Float64Array(data.length);\n    if (limit != null) {\n      max = Math.min(max, limit);\n    }\n    for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {\n      value = data[i];\n      if (max - min === 0) {\n        result[i] = 0;\n      } else {\n        result[i] = saturate((value - min) / (max - min));\n      }\n    }\n    return {\n      min: min,\n      max: max,\n      data: result\n    };\n  };\n  unscale = function(_arg) {\n    var data, delta, i, max, min, result, value, _i, _len;\n    min = _arg.min, max = _arg.max, data = _arg.data;\n    result = new Float64Array(data.length);\n    delta = max - min;\n    for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {\n      value = data[i];\n      result[i] = min + value * delta;\n    }\n    return result;\n  };\n  RGBtoXYLUM = function(data) {\n    var L, X, Y, b, g, i, l, pixels, r, x, y, z, _i;\n    pixels = data.length / 3;\n    L = new Float64Array(pixels);\n    X = new Float64Array(pixels);\n    Y = new Float64Array(pixels);\n    for (i = _i = 0; 0 <= pixels ? _i < pixels : _i > pixels; i = 0 <= pixels ? ++_i : --_i) {\n      r = data[i * 3 + 0];\n      g = data[i * 3 + 1];\n      b = data[i * 3 + 2];\n      x = r * 0.2209 + g * 0.1138 + b * 0.0102;\n      y = r * 0.339 + g * 0.678 + b * 0.1130;\n      z = r * 0.4184 + g * 0.7319 + b * 0.2969;\n      l = x + y + z;\n      L[i] = l;\n      X[i] = x / l;\n      Y[i] = y / l;\n    }\n    return {\n      x: X,\n      y: Y,\n      lum: L\n    };\n  };\n  XYLUMtoRGB = function(data) {\n    var b, g, i, lum, pixels, r, result, x, y, z, _i;\n    pixels = data.size * data.size;\n    result = new Float32Array(pixels * 3);\n    for (i = _i = 0; 0 <= pixels ? _i < pixels : _i > pixels; i = 0 <= pixels ? ++_i : --_i) {\n      x = data.x[i];\n      y = data.y[i];\n      lum = data.lum[i];\n      z = 1.0 - x - y;\n      x *= lum;\n      y *= lum;\n      z *= lum;\n      r = x * 6.0013 + y * -1.332 + z * 0.3007;\n      g = x * -2.7 + y * 3.1029 + z * -1.088;\n      b = x * -1.7995 + y * -5.772 + z * 5.6268;\n      result[i * 3 + 0] = r;\n      result[i * 3 + 1] = g;\n      result[i * 3 + 2] = b;\n    }\n    return result;\n  };\n  compressBlock2 = function(values, xoff, yoff, size, blockSize, writer) {\n    var blockValues, dstIdx, i, max, min, shortLimit, shortMax, shortMin, srcIdx, val0, val1, val2, val3, value, valueCount, x, y, _i, _j, _k, _results;\n    valueCount = blockSize * blockSize;\n    blockValues = new Float64Array(valueCount);\n    min = max = values[xoff + yoff * size];\n    dstIdx = 0;\n    for (y = _i = 0; 0 <= blockSize ? _i < blockSize : _i > blockSize; y = 0 <= blockSize ? ++_i : --_i) {\n      for (x = _j = 0; 0 <= blockSize ? _j < blockSize : _j > blockSize; x = 0 <= blockSize ? ++_j : --_j) {\n        srcIdx = (xoff + x) + (yoff + y) * size;\n        value = values[srcIdx];\n        min = Math.min(value, min);\n        max = Math.max(value, max);\n        blockValues[dstIdx] = value;\n        dstIdx += 1;\n      }\n    }\n    shortLimit = 256 * 256 - 1;\n    shortMin = Math.round(min * shortLimit);\n    shortMax = Math.round(max * shortLimit);\n    writer.uint16(shortMin);\n    writer.uint16(shortMax);\n    min = shortMin / shortLimit;\n    max = shortMax / shortLimit;\n    _results = [];\n    for (i = _k = 0; _k < valueCount; i = _k += 4) {\n      val0 = blockValues[i + 0];\n      val1 = blockValues[i + 1];\n      val2 = blockValues[i + 2];\n      val3 = blockValues[i + 3];\n      val0 = Math.round(saturate((val0 - min) / (max - min)) * 3);\n      val1 = Math.round(saturate((val1 - min) / (max - min)) * 3);\n      val2 = Math.round(saturate((val2 - min) / (max - min)) * 3);\n      val3 = Math.round(saturate((val3 - min) / (max - min)) * 3);\n      _results.push(writer.uint8((val0 << 6) | (val1 << 4) | (val2 << 2) | val3));\n    }\n    return _results;\n  };\n  compressBlock4 = function(values, xoff, yoff, size, blockSize, writer) {\n    var blockValues, dstIdx, i, max, min, shortLimit, shortMax, shortMin, srcIdx, val0, val1, value, valueCount, x, y, _i, _j, _k, _results;\n    valueCount = blockSize * blockSize;\n    blockValues = new Float64Array(valueCount);\n    min = max = values[xoff + yoff * size];\n    dstIdx = 0;\n    for (y = _i = 0; 0 <= blockSize ? _i < blockSize : _i > blockSize; y = 0 <= blockSize ? ++_i : --_i) {\n      for (x = _j = 0; 0 <= blockSize ? _j < blockSize : _j > blockSize; x = 0 <= blockSize ? ++_j : --_j) {\n        srcIdx = (xoff + x) + (yoff + y) * size;\n        value = values[srcIdx];\n        min = Math.min(value, min);\n        max = Math.max(value, max);\n        blockValues[dstIdx] = value;\n        dstIdx += 1;\n      }\n    }\n    shortLimit = 256 * 256 - 1;\n    shortMin = Math.round(min * shortLimit);\n    shortMax = Math.round(max * shortLimit);\n    writer.uint16(shortMin);\n    writer.uint16(shortMax);\n    min = shortMin / shortLimit;\n    max = shortMax / shortLimit;\n    _results = [];\n    for (i = _k = 0; _k < valueCount; i = _k += 2) {\n      val0 = blockValues[i + 0];\n      val1 = blockValues[i + 1];\n      val0 = Math.round(saturate((val0 - min) / (max - min)) * 15);\n      val1 = Math.round(saturate((val1 - min) / (max - min)) * 15);\n      _results.push(writer.uint8((val0 << 4) | val1));\n    }\n    return _results;\n  };\n  compress = function(_arg) {\n    var bits, blockSize, bpp, bufferSize, compressBlock, data, size, writer, x, y, _i, _j;\n    data = _arg.data, size = _arg.size, blockSize = _arg.blockSize, bits = _arg.bits;\n    bpp = bits / 8;\n    bufferSize = (size / blockSize) * (size / blockSize) * (4 + blockSize * blockSize * bpp);\n    writer = new stream.Writer(bufferSize);\n    if (bits === 4) {\n      compressBlock = compressBlock4;\n    } else if (bits === 2) {\n      compressBlock = compressBlock2;\n    }\n    for (y = _i = 0; blockSize > 0 ? _i < size : _i > size; y = _i += blockSize) {\n      for (x = _j = 0; blockSize > 0 ? _j < size : _j > size; x = _j += blockSize) {\n        compressBlock(data, x, y, size, blockSize, writer);\n      }\n    }\n    return {\n      data: writer.getBuffer(),\n      blockSize: blockSize,\n      bits: bits,\n      size: size\n    };\n  };\n  decompressBlock2 = function(result, xoff, yoff, size, blockSize, reader) {\n    var byte, max, min, shortLimit, srcIdx, val0, val1, val2, val3, x, y, _i, _j;\n    srcIdx = 0;\n    shortLimit = 256 * 256 - 1;\n    min = reader.uint16() / shortLimit;\n    max = reader.uint16() / shortLimit;\n    for (y = _i = 0; 0 <= blockSize ? _i < blockSize : _i > blockSize; y = 0 <= blockSize ? ++_i : --_i) {\n      for (x = _j = 0; _j < blockSize; x = _j += 4) {\n        byte = reader.uint8();\n        val0 = (byte >> 6) & 3;\n        val1 = (byte >> 4) & 3;\n        val2 = (byte >> 2) & 3;\n        val3 = byte & 3;\n        result[(xoff + x + 0) + (yoff + y) * size] = min + (val0 / 3) * (max - min);\n        result[(xoff + x + 1) + (yoff + y) * size] = min + (val1 / 3) * (max - min);\n        result[(xoff + x + 2) + (yoff + y) * size] = min + (val2 / 3) * (max - min);\n        result[(xoff + x + 3) + (yoff + y) * size] = min + (val3 / 3) * (max - min);\n      }\n    }\n  };\n  decompressBlock4 = function(result, xoff, yoff, size, blockSize, reader) {\n    var byte, max, min, shortLimit, srcIdx, val0, val1, x, y, _i, _j;\n    srcIdx = 0;\n    shortLimit = 256 * 256 - 1;\n    min = reader.uint16() / shortLimit;\n    max = reader.uint16() / shortLimit;\n    for (y = _i = 0; 0 <= blockSize ? _i < blockSize : _i > blockSize; y = 0 <= blockSize ? ++_i : --_i) {\n      for (x = _j = 0; _j < blockSize; x = _j += 2) {\n        byte = reader.uint8();\n        val0 = (byte >> 4) & 15;\n        val1 = byte & 15;\n        result[(xoff + x + 0) + (yoff + y) * size] = min + (val0 / 15) * (max - min);\n        result[(xoff + x + 1) + (yoff + y) * size] = min + (val1 / 15) * (max - min);\n      }\n    }\n  };\n  decompress = function(_arg) {\n    var bits, blockSize, data, decompressBlock, reader, result, size, x, y, _i, _j;\n    data = _arg.data, size = _arg.size, blockSize = _arg.blockSize, bits = _arg.bits;\n    result = new Float64Array(size * size);\n    reader = new stream.Reader(data);\n    if (bits === 4) {\n      decompressBlock = decompressBlock4;\n    } else if (bits === 2) {\n      decompressBlock = decompressBlock2;\n    }\n    for (y = _i = 0; blockSize > 0 ? _i < size : _i > size; y = _i += blockSize) {\n      for (x = _j = 0; blockSize > 0 ? _j < size : _j > size; x = _j += blockSize) {\n        decompressBlock(result, x, y, size, blockSize, reader);\n      }\n    }\n    return result;\n  };\n  exports = {\n    compress: function(_arg) {\n      var data, quality, size;\n      data = _arg.data, size = _arg.size, quality = _arg.quality;\n      if (quality == null) {\n        quality = {\n          x: {\n            bits: 2,\n            blockSize: 8\n          },\n          y: {\n            bits: 2,\n            blockSize: 8\n          },\n          lum: {\n            bits: 4,\n            blockSize: 4\n          }\n        };\n      }\n      data = RGBtoXYLUM(data);\n      data.size = size;\n      data.lum = scale(data.lum, 192);\n      data.x = scale(data.x);\n      data.y = scale(data.y);\n      data.x.data = compress({\n        data: data.x.data,\n        size: size,\n        blockSize: quality.x.blockSize,\n        bits: quality.x.bits\n      });\n      data.y.data = compress({\n        data: data.y.data,\n        size: size,\n        blockSize: quality.y.blockSize,\n        bits: quality.y.bits\n      });\n      data.lum.data = compress({\n        data: data.lum.data,\n        size: size,\n        blockSize: quality.lum.blockSize,\n        bits: quality.lum.bits\n      });\n      return data;\n    },\n    decompress: function(data) {\n      var lum, x, y;\n      x = decompress(data.x.data);\n      y = decompress(data.y.data);\n      lum = decompress(data.lum.data);\n      x = unscale({\n        min: data.x.min,\n        max: data.x.max,\n        data: x\n      });\n      y = unscale({\n        min: data.y.min,\n        max: data.y.max,\n        data: y\n      });\n      lum = unscale({\n        min: data.lum.min,\n        max: data.lum.max,\n        data: lum\n      });\n      return XYLUMtoRGB({\n        x: x,\n        y: y,\n        lum: lum,\n        size: data.size\n      });\n    }\n  };\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/compression/stream.coffee":{"modified":1444332329274,"content":"sys.defModule('/compression/stream', function(exports, require, fs) {\n  var Reader, Writer;\n  exports.Writer = Writer = (function() {\n    function Writer(initialSize) {\n      if (initialSize == null) {\n        initialSize = 1024;\n      }\n      this.buffer = new ArrayBuffer(initialSize);\n      this.view = new DataView(this.buffer);\n      this.offset = 0;\n    }\n\n    Writer.prototype.checkSize = function(bytesToWrite) {\n      var remaining;\n      remaining = this.buffer.byteLength - this.offset;\n      if (remaining < bytesToWrite) {\n        return this.enlarge(bytesToWrite - remaining);\n      }\n    };\n\n    Writer.prototype.enlarge = function(minimum) {\n      var dst, newBuffer, newSize, src;\n      newSize = Math.max(this.buffer.byteLength * 2, this.buffer.byteLength + minimum * 2);\n      newBuffer = new ArrayBuffer(newSize);\n      src = new Uint8Array(this.buffer);\n      dst = new Uint8Array(newBuffer);\n      dst.set(src);\n      this.buffer = newBuffer;\n      return this.view = new DataView(this.buffer);\n    };\n\n    Writer.prototype.uint8 = function(value) {\n      this.checkSize(1);\n      this.view.setUint8(this.offset, value, true);\n      return this.offset += 1;\n    };\n\n    Writer.prototype.int8 = function(value) {\n      this.checkSize(1);\n      this.view.setInt8(this.offset, value, true);\n      return this.offset += 1;\n    };\n\n    Writer.prototype.uint16 = function(value) {\n      this.checkSize(2);\n      this.view.setInt16(this.offset, value, true);\n      return this.offset += 2;\n    };\n\n    Writer.prototype.int16 = function(value) {\n      this.checkSize(2);\n      this.view.setUint16(this.offset, value, true);\n      return this.offset += 2;\n    };\n\n    Writer.prototype.uint32 = function(value) {\n      this.checkSize(4);\n      this.view.setUint32(this.offset, value, true);\n      return this.offset += 4;\n    };\n\n    Writer.prototype.int32 = function(value) {\n      this.checkSize(4);\n      this.view.setInt32(this.offset, value, true);\n      return this.offset += 4;\n    };\n\n    Writer.prototype.float32 = function(value) {\n      this.checkSize(4);\n      this.view.setFloat32(this.offset, value, true);\n      return this.offset += 4;\n    };\n\n    Writer.prototype.float64 = function(value) {\n      this.checkSize(8);\n      this.view.setFloat64(this.offset, value, true);\n      return this.offset += 8;\n    };\n\n    Writer.prototype.getBuffer = function() {\n      return this.buffer.slice(0, this.offset);\n    };\n\n    return Writer;\n\n  })();\n  exports.Reader = Reader = (function() {\n    function Reader(buffer) {\n      this.buffer = buffer;\n      this.view = new DataView(buffer);\n      this.offset = 0;\n    }\n\n    Reader.prototype.uint8 = function() {\n      var value;\n      value = this.view.getUint8(this.offset, true);\n      this.offset += 1;\n      return value;\n    };\n\n    Reader.prototype.uint8array = function(length) {\n      var value;\n      value = new Uint8Array(this.buffer, this.offset, length);\n      this.offset += length;\n      return value;\n    };\n\n    Reader.prototype.int8 = function() {\n      var value;\n      value = this.view.getInt8(this.offset, true);\n      this.offset += 1;\n      return value;\n    };\n\n    Reader.prototype.int8array = function(length) {\n      var value;\n      value = new Int8Array(this.buffer, this.offset, length);\n      this.offset += length;\n      return value;\n    };\n\n    Reader.prototype.uint16 = function() {\n      var value;\n      value = this.view.getUint16(this.offset, true);\n      this.offset += 2;\n      return value;\n    };\n\n    Reader.prototype.uint16array = function(length) {\n      var padding, value;\n      padding = this.offset % 2;\n      this.offset += padding;\n      value = new Uint16Array(this.buffer, this.offset, length);\n      this.offset += length * 2;\n      return value;\n    };\n\n    Reader.prototype.int16 = function() {\n      var value;\n      value = this.view.getInt16(this.offset, true);\n      this.offset += 2;\n      return value;\n    };\n\n    Reader.prototype.int16array = function(length) {\n      var padding, value;\n      padding = this.offset % 2;\n      this.offset += padding;\n      value = new Int16Array(this.buffer, this.offset, length);\n      this.offset += length * 2;\n      return value;\n    };\n\n    Reader.prototype.uint32 = function() {\n      var value;\n      value = this.view.getUint32(this.offset, true);\n      this.offset += 4;\n      return value;\n    };\n\n    Reader.prototype.uint32array = function(length) {\n      var padding, value;\n      padding = (4 - (this.offset % 4)) % 4;\n      this.offset += padding;\n      value = new Uint32Array(this.buffer, this.offset, length);\n      this.offset += length * 4;\n      return value;\n    };\n\n    Reader.prototype.int32 = function() {\n      var value;\n      value = this.view.getInt32(this.offset, true);\n      this.offset += 4;\n      return value;\n    };\n\n    Reader.prototype.int32array = function(length) {\n      var padding, value;\n      padding = (4 - (this.offset % 4)) % 4;\n      this.offset += padding;\n      value = new Int32Array(this.buffer, this.offset, length);\n      this.offset += length * 4;\n      return value;\n    };\n\n    Reader.prototype.float32 = function() {\n      var value;\n      value = this.view.getFloat32(this.offset, true);\n      this.offset += 4;\n      return value;\n    };\n\n    Reader.prototype.float32array = function(length) {\n      var padding, value;\n      padding = (4 - (this.offset % 4)) % 4;\n      this.offset += padding;\n      value = new Float32Array(this.buffer, this.offset, length);\n      this.offset += length * 4;\n      return value;\n    };\n\n    Reader.prototype.float64 = function() {\n      var value;\n      value = this.view.getFloat64(this.offset, true);\n      this.offset += 8;\n      return value;\n    };\n\n    Reader.prototype.float64array = function(length) {\n      var padding, value;\n      padding = (8 - (this.offset % 8)) % 8;\n      this.offset += padding;\n      value = new Float64Array(this.buffer, this.offset, length);\n      this.offset += length * 8;\n      return value;\n    };\n\n    Reader.prototype.arraybuffer = function(length) {\n      var result;\n      result = this.buffer.slice(this.offset, this.offset + length);\n      this.offset += length;\n      return result;\n    };\n\n    return Reader;\n\n  })();\n  return exports;\n});"},"/root/www/codeflow/webgl/envmapper3/src/chart.coffee":{"modified":1444913621558,"content":"sys.defModule('/chart', function(exports, require, fs) {\n  var Chart;\n  exports = Chart = (function() {\n    function Chart() {\n      this.canvas = $('<canvas></canvas>').css({\n        width: 512,\n        height: 512,\n        backgroundColor: '#111',\n        position: 'absolute',\n        top: 0,\n        right: 0\n      }).appendTo('body')[0];\n      this.canvas.width = 512;\n      this.canvas.height = 512;\n      this.ctx = this.canvas.getContext('2d');\n      this.ctx.strokeStyle = '#fff';\n      this.values = null;\n      this.pointCount = 100;\n    }\n\n    Chart.prototype.clear = function() {\n      return this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    };\n\n    Chart.prototype.drawSeries = function(series, x0, y0, width, height) {\n      var b, g, max, r, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;\n      if (series.length === 0) {\n        return;\n      }\n      _ref = series[0], r = _ref[0], g = _ref[1], b = _ref[2];\n      max = 0;\n      max = Math.max(max, r);\n      max = Math.max(max, g);\n      max = Math.max(max, b);\n      for (_i = 0, _len = series.length; _i < _len; _i++) {\n        _ref1 = series[_i], r = _ref1[0], g = _ref1[1], b = _ref1[2];\n        max = Math.max(max, r);\n        max = Math.max(max, g);\n        max = Math.max(max, b);\n      }\n      this.ctx.strokeStyle = 'red';\n      this.ctx.moveTo(0, 0);\n      this.ctx.beginPath();\n      for (x = _j = 0, _len1 = series.length; _j < _len1; x = ++_j) {\n        _ref2 = series[x], r = _ref2[0], g = _ref2[1], b = _ref2[2];\n        x = x0 + (x / this.pointCount) * width;\n        y = y0 + (r / max) * height;\n        this.ctx.lineTo(x, y);\n      }\n      this.ctx.stroke();\n      this.ctx.strokeStyle = 'green';\n      this.ctx.moveTo(0, 0);\n      this.ctx.beginPath();\n      for (x = _k = 0, _len2 = series.length; _k < _len2; x = ++_k) {\n        _ref3 = series[x], r = _ref3[0], g = _ref3[1], b = _ref3[2];\n        x = x0 + (x / this.pointCount) * width;\n        y = y0 + (g / max) * height;\n        this.ctx.lineTo(x, y);\n      }\n      this.ctx.stroke();\n      this.ctx.strokeStyle = 'blue';\n      this.ctx.moveTo(0, 0);\n      this.ctx.beginPath();\n      for (x = _l = 0, _len3 = series.length; _l < _len3; x = ++_l) {\n        _ref4 = series[x], r = _ref4[0], g = _ref4[1], b = _ref4[2];\n        x = x0 + (x / this.pointCount) * width;\n        y = y0 + (b / max) * height;\n        this.ctx.lineTo(x, y);\n      }\n      return this.ctx.stroke();\n    };\n\n    Chart.prototype.update = function(data) {\n      var b, color, g, i, r, series, values, _i, _j, _len, _len1, _ref, _ref1, _results;\n      if (this.values == null) {\n        this.values = (function() {\n          var _i, _len, _results;\n          _results = [];\n          for (_i = 0, _len = data.length; _i < _len; _i++) {\n            color = data[_i];\n            _results.push([]);\n          }\n          return _results;\n        })();\n      }\n      for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {\n        _ref = data[i], r = _ref[0], g = _ref[1], b = _ref[2];\n        if (!isNaN(r)) {\n          values = this.values[i];\n          values.push([r, g, b]);\n          if (values.length > this.pointCount) {\n            values.shift();\n          }\n        }\n      }\n      this.clear();\n      _ref1 = this.values;\n      _results = [];\n      for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {\n        series = _ref1[i];\n        _results.push(this.drawSeries(series, 10, 10 + 60 * i, this.canvas.width - 20, 50));\n      }\n      return _results;\n    };\n\n    return Chart;\n\n  })();\n  return exports;\n});"}}